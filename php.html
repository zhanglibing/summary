<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>PHP</title>
  <meta name="description" content="fullstack web developer">
  <link rel="stylesheet" href="css/main.css">
</head>
<body>
<header class="site-header">
  <div class="wrapper">
    <a class="site-title" href="https://github.com/zhanglibing">zhanglibing</a>
  </div>
</header>

<div class="wrapper">
    <h2>Php</h2>
    <pre class="highlight"><code>
WAMPServer集成环境下载和安装
W: windows
A:Apache
M:MySQL
P:php
www.wampserver.com/en/#begin-wrapper
 <span class="b">1.代码标识</span>
 <span class="x">&lt;?php  代码  ?&gt;</span>
 <span class="b">2.echo语句</span>
 <span class="x">echo</span> "Welcome to imooc!";  注意echo关键字与字符串之间至少要有一个空格
 <span class="b">3.字符串连接</span>
 <span class="kc">1  .</span>  ：它返回将右参数附加到左参数后面所得的字符串。
 <span class="x">2  .=</span>  ：它将右边参数附加到左边的参数后。
    $b = "东边日出西边雨";
    $b <span class="x">.= </span>",道是无晴却有晴";
    $c = "东边日出西边雨";
    $c = $c<span class="x">.</span>",道是无晴却有晴";
<span class="b">4.PHP语句结束符</span>
  注意在每一条PHP代码行结尾处都会有一个<span class="x">分号;</span>
<span class="b">5.用双斜杠注释</span>
<span class="b">6.定义变量</span>
  <span class="x">$var_name</span> = “苹果”;
  <span class="x">$n</span> = 10;
  <span class="b">7.变量名的命名规则和js一样</span>
  <span class="b">8.变量的数据类型</span>
  <span class="kd">字符串类型</span>，<span class="kd">整型</span>，<span class="kd">浮点型</span>和 <span class="kd">数组</span>
  <span class="b">9.标量类型—布尔类型</span>
      布尔类型（boolean）它不区分大小写
 <span class="b">10.字符串类型</span>
    字符串包含引号的情况
    $str_string1 = '甲问："你在哪里学的PHP？"';
    $str_string2 = "乙毫不犹豫地回答：'当然是慕课网咯！'";
    $str_string3 = '甲问:\'能告诉我网址吗？\'';
    $str_string4 = "乙答道:\"www.imooc.com\"";

    $love = "I love you!";
    $string1 = "test,$love"; //test,I love you!
    $string2 = 'test,$love'; //test,$love
    <span class="k">当双引号中包含变量时，变量会与双引号中的内容连接在一起；
    当单引号中包含变量时，变量会被当做字符串输出。</span>

 <span class="b">11.常量</span>
    <span class="k">常量主要功效是可以避免重复定义，篡改变量值。</span>
    <span class="x">define</span>("PI",3.14);  注意为双引号
     echo PI;
 <span class="b">系统常量</span>
 <span class="x">__FILE__</span> :php程序文件名。它可以帮助我们获取当前文件在服务器的物理位置。
 <span class="x">__LINE__</span> :PHP程序文件行数。它可以告诉我们，当前代码在第几行。
 <span class="x">PHP_VERSION</span>:当前解析器的版本号。它可以告诉我们当前PHP解析器的版本号，我们可以提前知道我们的PHP代码是否可被该PHP解析器解析。
 <span class="x">PHP_OS</span>：执行当前PHP版本的操作系统名称。它可以告诉我们服务器所用的操作系统名称，我们可以根据该操作系统优化我们的代码。
 <span class="b">常量如何取值</span>
 <span class="x">第一种</span>是使用常量名直接获取值
 <span class="x">第二种</span>是使用constant()函数  函数可以动态的输出不同的常量，在使用上要灵活、方便
 $height = "中";
//根据精度返回常量名，将常量变成了一个可变的常量
if($height == "中"){
    $p = "PI1";
}else if($height == "低"){
	$p = "PI2";
}
$r=1;
$area=constant($p)*$r*$r;
echo $area;
<span class="b">如何判定常量是否被定义</span>
<span class="kd">defined()</span>函数可以帮助我们判断一个常量是否已经定义
define("PI1",3.14);
$p = "PI1";
$is1 = <span class="x">defined</span>($p);
echo ($is1);
<span class="b">运算符</span>
 <span class="x">+  -  * / </span>
赋值运算符有两种
 <span class="x"> =  &</span>
<span class="x">&</span>：引用赋值，意味着两个变量都指向同一个数据。它将使两个变量共享一块内存，如果这个内存存储的数据变了，
 那么两个变量的值都会发生变化。
$a = "aaaa！";
$b = $a;
$c = &$a;
$a = "changeaaa！";
echo $b;  //aaaa！
echo $c;  // changeaaa！

==  === != <>不等于 !==不等于、或者类型不同  <  > <=  >=
<span class="b">三元运算符</span>
$b = $a >= 60 ? "及格": "不及格";
<span class="b">逻辑运算符</span>
 ||  &&  !
 <span class="x">and  or  xor</span>异或（只能有一个正确的）
    $a = TRUE; //A同意
    $b = TRUE; //B同意
    $c = FALSE; //C反对
    $d = FALSE; //D反对
    echo <span class="b">(</span>$a and $b <span class="b">)</span>?"通过":"不通过";
    echo ($a or $c)?"通过":"不通过";
    echo ($a xor $c xor $d xor $b)?"通过":"不通过"; <span class="kd">//不通过</span>
    echo ($a xor $c xor $d)?"通过":"不通过";  <span class="kd">//通过</span>
    echo $b || $c || $d?"通过":"不通过"

 <span class="b">错误控制运算符</span>
<span class="k">PHP中提供了一个错误控制运算符“@”，对于一些可能会在运行过程中出错的表达式时，我们不希望出错的时候给客户
显示错误信息，这样对用户不友好。于是，可以将@放置在一个PHP表达式之前，该表达式可能产生的任何错误信息都被忽略掉</span>；
<span class="x">注意：错误控制前缀“@”不会屏蔽解析错误的信息，不能把它放在函数或类的定义之前，也不能用于条件结构例如if和foreach等。</span>
 $conn =<span class="x">@</span> mysql_connect("localhost","username","password");
 echo "出错了，错误原因是：".<span class="x">$php_errormsg</span>;
 <span class="b">语句结构</span>
    if(){} else{}
    if else if  else
    <span class="x">switch</span>switch (条件){
        case 条件值一:
          //任务一
          break;
        case 条件值二:
          //任务二
          break;
        default:
          //默认任务
    }
   <span class="x">while</span>(条件){
     //执行任务
   }
   do{
     //执行任务
   }while(条件)
   <span class="b">for语句写法</span>
    for($i = 1,$sum = 0;$i<=100;$i++){
        $sum = $sum + $i; //	累加求和
    }
<span class="b">foreach</span>
foreach($students as $v){
    echo $v;//输出（打印）姓名
}
foreach($students as $key => $v){
    echo $v;//输出（打印）姓名
    echo $key;//输出下标
}
    </code></pre>
</div>
<!--Array-->
<div class="wrapper">
    <h2>数组</h2>
    <pre class="highlight"><code>
$arr = <span class="x">array()</span>;表示创建一个空数组，并把创建的空数组赋值给变量$arr。
 PHP有两种数组：索引数组、关联数组。
<span class="b">索引数组</span>，索引数组是指数组的键是整数的数组，并且键的整数顺序是从0开始，依次类推
$fruit = <span class="x">array</span>("苹果","香蕉","菠萝");
print_r($fruit);
Array
(
    [0] => 苹果
    [1] => 香蕉
    [2] => 菠萝
)
<span class="b">索引数组赋值三种方法</span>
<span class="x">$arr[0]</span>='苹果';
<span class="x">array</span>('0'=>'苹果');
array('苹果');
<span class="b">访问索引数组内容</span>
$fruit = array('苹果','香蕉');
$fruit0 = $fruit<span class="x">[0]</span>;
print_r($fruit0);//结果为苹果
<span class="b">for循环访问索引数组里的值</span>
$fruit=array('苹果','香蕉','菠萝');
for($i=0; $i<3; $i++){
    echo '数组第'.$i.'值是：'.$fruit[$i];
}
<span class="b">foreach循环访问索引数组里的值</span>
$fruit=array('苹果','香蕉','菠萝');
foreach($fruit as $k=>$v){
    echo '<br>第'.$k.'值是：'.$v;
}

<span class="b">关联数组初始化 </span>
$fruit = array(
    'apple'=>"苹果",
    'banana'=>"香蕉",
    'pineapple'=>"菠萝"
);
<span class="b">关联数组赋值两种方法</span>
$arr['apple']='苹果';
$arr=array('apple'=>'苹果');

<span class="b">取值</span>
$arr = array('apple'=>"苹果",'banana'=>"香蕉",'pineapple'=>"菠萝");
$arr0=$arr['apple'] ;
foreach循环访问关联数组里的值和索引数组类似
    </code></pre>
</div>
<!--Object\Class-->
<div class="wrapper">
    <h2>类和对象</h2>
    <pre class="highlight"><code>
//定义一个类
<span class="x">class</span> Car {
    <span class="x">var</span> $name = '汽车';  <span class="k">类里边记得var</span>
    function getName() {
        return $this<span class="x">-></span>name;
    }
}
//实例化一个car对象
$car = new Car();
<span class="x">$car->name = '奥迪A6'</span>; //设置对象的属性值
echo $car<span class="x">->getName()</span>;  //调用对象的方法 输出对象的名字

<span class="b">类和对象之类的属性</span>
<span class="k">属性声明是由关键字 public，protected 或者 private 开头，后面跟一个普通的变量声明来组成。
    属性的变量可以设置初始化的默认值，默认值必须是常量</span>
<span class="x">public</span>：公开的
<span class="x">protected</span>：受保护的
<span class="x">private</span>：私有的
 <span class="kd">class</span> Car {
    //定义公共属性
    public $name = '汽车';
    //定义受保护的属性
    protected $corlor = '白色';
    //定义私有属性
    private $price = '100000';
}
<span class="kd">$car</span> = new Car();
echo <span class="kd">$car->name</span>;   //调用对象的属性
echo <span class="kd">$car->color</span>;  <span class="x">//错误 受保护的属性不允许外部调用</span>
echo <span class="kd">$car->price</span>;  <span class="x">//错误 私有属性不允许外部调用</span>
<span class="b">类和对象之定义类的方法</span>
<span class="kd">class</span> Car {
    public <span class="kc">function</span> <span class="kd">getName</span>() {
        return '汽车';
    }
​}
$car = new Car();
echo <span class="kd">$car->getName()</span>;

<span class="b">类和对象之构造函数和析构函数</span>
<span class="k">使用__construct()定义一个构造函数，具有构造函数的类，会在每次对象创建的时候调用该函数，
 因此常用来在对象创建的时候进行一些初始化工作。</span>

<span class="b">类和对象之Static静态关键字</span>
<span class="k">静态属性与方法可以在不实例化类的情况下调用，直接使用类名::方法名的方式进行调用。
静态属性不允许对象使用->操作符调用。</span>
<span class="kd">class</span> Car {
    private static $speed = 10;
    public static function getSpeed() {
        return <span class="x">self::$speed</span>;
    }
}
echo <span class="kd">Car::getSpeed()</span>;  //调用静态方法
<span class="kc">静态方法也可以通过变量来进行动态调用</span>
$func = 'getSpeed';
$className = 'Car';
echo <span class="kd">$className::$func();</span>  //动态调用静态方法
<span class="kc">静态方法中，$this伪变量不允许使用。可以使用self，parent，static在
   内部调用静态方法与属性。</span>
class Car {
    private static $speed = 10;

    public static function getSpeed() {
        return self::$speed;
    }

    public static function speedUp() {
        return self::$speed+=10;
    }
}
class BigCar extends Car {
    public static function start() {
        <span class="x">parent::speedUp()</span>;
    }
}
BigCar::start();
echo BigCar::getSpeed();
<span class="b">类和对象之访问控制</span>
访问控制通过关键字public，protected和private来实现。
被定义为公有的类成员可以在任何地方被访问。
被定义为受保护的类成员则可以被其自身以及其子类和父类访问。
被定义为私有的类成员则只能被其定义所在的类访问。
<span class="x">类属性必须定义</span>为公有、受保护、私有之一。
 为兼容PHP5以前的版本，如果采用 var 定义，则被视为公有。
<span class="kd">class</span> Car {
    $speed = 10; <span class="x">//错误 属性必须定义访问控制</span>
    public $name;   //定义共有属性
}

<span class="b">类和对象之对象继承</span>
class Car {
    public $speed = 0; //汽车的起始速度是0
    public function speedUp() {
        $this->speed += 10;
        return $this->speed;
    }
}
//定义继承于Car的Truck类
class Truck extends Car{
    public function speedUp() {
        <span class="x">parent::speedUp();</span>
        $this->speed += 50;
        return $this->speed;
    }
}

$car = new Truck();
$car->speedUp();
echo $car->speed;

<span class="b">类和对象之重载</span>
PHP中的重载指的是动态的创建属性与方法，是通过魔术方法来实现的。
<span class="x">属性的重载通过</span>__set，__get，__isset，__unset来分别实现
对不存在属性的赋值、读取、判断属性是否设置、销毁属性。
class Car {
    private $ary = array();

    public function __set($key, $val) {
        $this->ary[$key] = $val;
    }

    public function __get($key) {
        if (isset($this->ary[$key])) {
            return $this->ary[$key];
        }
        return null;
    }

    public function __isset($key) {
        if (isset($this->ary[$key])) {
            return true;
        }
        return false;
    }

    public function __unset($key) {
        unset($this->ary[$key]);
    }
}
$car = new Car();
$car->name = '汽车';  //name属性动态创建并赋值
echo $car->name;

<span class="x">方法的重载通过__call来实现</span>，当调用不存在的方法的时候，将会转为参数调用__call方法，
当调用不存在的静态方法时会使用__callStatic重载。
<span class="kd">class</span> Car {
    public $speed = 0;

    public function <span class="kd">__call</span>($name, $args) {
        if ($name == 'speedUp') {
            $this->speed += 10;
        }
    }
}
$car = new Car();
<span class="x">$car->speedUp()</span>; //调用不存在的方法会使用重载
echo $car->speed;
<span class="b">类和对象之对象的高级特性</span>
<span class="x">对象比较</span>
当<span class="kd">同一个类的两个实例</span>的所有属性都相等时，可以使用比较运算符==进行判断，
当需要判断<span class="kd">两个变量是否为同一个对象的引用</span>时，可以使用全等运算符===进行判断。
<span class="kd">class</span> Car {
}
$a = new Car();
$b = new Car();
if ($a == $b) echo '==';   <span class="x">//true</span>
if ($a === $b) echo '==='; <span class="x">//false</span>

<span class="x">对象复制</span>
 在一些特殊情况下，可以通过关键字clone来复制一个对象，这时__clone方法会被调用，
 通过这个魔术方法来设置属性的值。
class Car {
    public $name = 'car';

    public function __clone() {
        $obj = new Car();
        $obj->name = $this->name;
    }
}
$a = new Car();
$a->name = 'new car';
$b = clone $a;
var_dump($b);
<span class="x">对象序列化</span>
可以通过serialize方法将对象序列化为字符串，用于存储或者传递数据，
然后在需要的时候通过unserialize将字符串反序列化成对象进行使用。
class Car {
    public $name = 'car';
}
$a = new Car();
$str = serialize($a); //对象序列化成字符串
echo $str.'<br>';
$b = unserialize($str); //反序列化为对象
var_dump($b);
    </code></pre>
</div>
<div class="wrapper">
    <h2>正则表达式</h2>
    <pre class="highlight"><code>
<span class="b">preg_match</span>
`$p = '/apple/';
$str = "apple banna";
if (preg_match($p, $str)) {
    echo 'matched';
}
PCRE库函数中，正则匹配模式使用分隔符与元字符组成，分隔符可以是非数字、非反斜线、非空格的任意字符。
经常使用的分隔符是正斜线(/)、hash符号(#) 以及取反符号(~)，例如：
/foo bar/
#^[^0-9]$#
~php~
<span class="x">如果模式中包含分隔符</span>，则分隔符需要使用反斜杠（\）进行转义。
/http:\/\//
<span class="x">如果模式中包含较多的分割字符</span>，建议更换其他的字符作为分隔符，也可以采用preg_quote进行转义。

$p = 'http://';
$p = '/'.<span class="kd">preg_quote</span>($p, '/').'/';
echo $p;
分隔符后面可以使用模式修饰符，模式修饰符包括：<span class="x">i, m, s, x</span>等，
例如使用i修饰符可以忽略大小写匹配：
$str = "Http://www.imooc.com/";
if (preg_match('/http/i', $str)) {
    echo '匹配成功';
}

<span class="b">元字符与转义</span>
<span class="kd">\</span> 一般用于转义字符
<span class="kd">^</span> 断言目标的开始位置(或在多行模式下是行首)
<span class="kd">$</span> 断言目标的结束位置(或在多行模式下是行尾)
<span class="kd">.</span> 匹配除换行符外的任何字符(默认)
<span class="kd">[</span> 开始字符类定义
<span class="kd">]</span> 结束字符类定义
<span class="kd">|</span> 开始一个可选分支
<span class="kd">(</span> 子组的开始标记
<span class="kd">)</span> 子组的结束标记
<span class="kd">?</span> 作为量词，表示 0 次或 1 次匹配。位于量词后面用于改变量词的贪婪特性。 (查阅量词)
<span class="kd">*</span> 量词，0 次或多次匹配
<span class="kd">+</span> 量词，1 次或多次匹配
<span class="kd">{</span> 自定义量词开始标记
<span class="kd">}</span> 自定义量词结束标记


    </code></pre>
</div>

<div class="wrapper">
    <h2>php连接Mysql</h2>
    <pre class="highlight"><code>
php内置Mysql函数
mysql_fetch_row()取一条数据产生的索引数组  请求速度比array快的多
mysql_fetch_array()默认状态下取一条数据产生一个索引数组和一个关联数组
&lt;?php
  header("Content-type:teat/html;charset=utf-8");
   //连接数据库、选择数据库、设定字符集
  mysql_connect('localhost','root','123456'); 域名、账号、密码
  mysql_select_db('info');//选择数据库
  mysql_query('set names utf8');   //设定字符集 设置一下当前连接使用的字符编码
  //发指令、获取数据
  $query = mysql_query('select * from test'); 根据sql语句获取数据
  $arr=mysql_fetch_array($query);
  mysql_fetch_array的第二个参数
        1.MYSQL_ASSOC -关联数组
        1.MYSQL_NUM -索引数组
        1.MYSQL_BOTH -默认
  $arr=mysql_fetch_array($query,MYSQL_ASSOC);
  print_r($arr);
?&gt;
    </code></pre>
</div>
<footer class="site-footer">
  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col">
        <ul class="social-media-list">
          <li>
            <a href="https://github.com/zhanglibing"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path
                    fill="#828282"
                    d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg></span><span
                    class="username">zhanglibing</span></a>
          <span>fullstack web developer</span>
          </li>
        </ul>
      </div>
    </div>
  </div>

</footer>

</body>
</html>
