<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>VUE</title>
    <link rel="stylesheet" href="css/index.css">
    <link rel="stylesheet" href="css/main.css">
</head>
<body>
<header class="site-header">
    <div class="wrapper">
        <a class="site-title" href="https://github.com/zhanglibing">zhanglibing</a>
    </div>
</header>
<!--vue-->
<div class="wrapper">
<h2><a href="http://cn.vuejs.org/v2/guide/">VUE API</a></h2>
    <h1>VUEJS</h1>

    <ul>
        <li>
          <p>手机端测试方法</p>
          <pre class="highlight">
            <code>
 ipconfig（window系统）
 ifconfig（苹果系统）
 找到IPv4 地址 . . . : 192.168.31.180
 将localhost替换为192.168.31.180
 手机直接搜索网址进行测试  或者  进入网址cli.im   打开草料二维码   将网址生成二维码进行扫码测试
            </code></pre>
        </li>
        <li>
            <p>创建vue项目</p>
            <pre class="highlight">
                <code>
 <span class="x">npm install -g vue-cli</span>(如果电脑已安装过直接跳过)
 <span class="x">vue init webpack myapp</span>(项目名称)都选择no,项目生成好后cd到当前项目
 <span class="x">npm install</span>，安装所有依赖到node_modules目录中 （npm版本过低用npm install npm -g升级）
 <span class="x">npm run dev</span>运行项目
                </code></pre>
        </li>
    </ul>

</div>
<div class="wrapper">
    <p>1.数据渲染</p>
    <pre class="highlight">
        <code>
 v-text、v-html、 {{}}
 <span class="nt">&lt;p&gt;{{a}}&lt;/p&gt;</span>
 <span class="nt">&lt;p <span class="x">v-text="a"</span>&gt; </span>&lt;/p&gt;
 <span class="nt">&lt;p <span class="x">v-html="a"</span>&gt; </span>&lt;/p&gt;            
        </code></pre>
</div>
<div class="wrapper">
<p>2.控制模块隐藏：v-if、 v-show</p>
    <pre class="highlight">
        <code>
 &lt;p <span class="x">v-if="isShow"</span>&gt; &lt;/p&gt;
 &lt;p <span class="x">v-show="isShow"</span>&gt;&lt;/p&gt;  
一般来说， v-if 有更高的切换消耗而 v-show 有更高的
初始渲染消耗。因此，如果需要<span class="x">频繁切换使用 v-show</span> 较好，
如果在运行时条件<span class="x">不大可能改变</span>则使用 v-if 较好。          
        </code></pre>
</div>
<div class="wrapper">
    <p>3.渲染循环列表</p>
    <pre class="highlight"><code>
<span class="nt">&lt;ul&gt;</span>
  <span class="nt">&lt;li</span> <span class="x">v-for='item in items'</span> <span class="nt">&gt;</span>
     <span class="nt">&lt;p </span> <span class="x">v-text='item.lable'</span><span class="nt">&gt;</span><span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;/li&gt;</span>
<span class="nt">&lt;/ul&gt;</span>   
<span class="nt">&lt;li</span> v-for="(item, <span class="x">index</span>) in items"<span class="nt">&gt;</span>index当前项的索引
   {{ parentMessage }}-{{ index }}-{{ item.message }}

对象迭代 v-for
你也可以用 v-for 通过一个对象的属性来迭代。
<span class="nt">&lt;ul</span>  id="repeat-object" class="demo"<span class="nt">&gt;</span> 
  <span class="nt">&lt;/li</span> v-for="value in <span class="x">object</span>"<span class="nt">&gt;</span>
    {{ value }}
  <span class="nt">&lt;/li&gt;</span>
<span class="nt">&lt;/ul&gt;</span> 
new Vue({
  el: '#repeat-object',
  data: {
    <span class="x">object</span>: {
      FirstName: 'John',
      LastName: 'Doe',
      Age: 30
    }
  }
})   
<span class="nt">&lt;/li&gt;</span>  
你也可以提供第二个的参数为键名：
<span class="nt">&lt;/div</span>  v-for="(<span class="x">value, key</span>) in object"<span class="nt">&gt;</span> 
  {{ key }} : {{ value }}
<span class="nt">&lt;/div&gt;</span> 
第三个参数为索引：
<span class="nt">&lt;/div</span>  v-for="(<span class="x">value, key, index</span>) in object"<span class="nt">&gt;</span> 
  {{ index }}. {{ key }} : {{ value }}
<span class="nt">&lt;/div&gt;</span> 

整数迭代 v-for
v-for 也可以取整数。在这种情况下，它将重复多次模板。
<span class="nt">&lt;div&gt;</span> 
  <span class="nt">&lt;span&gt;</span>  v-for="n in 10"<span class="nt">&gt;</span> {{ n }}<span class="nt">&lt;/span&gt;</span> 
<span class="nt">&lt;/div&gt;</span>   结果：1 2 3 4 5 6 7 8 9 10 
        </code></pre>
</div>
<div class="wrapper">
<p>4.事件绑定</p>
    <pre class="highlight">
        <code>
<span class="nt">&lt;button</span> <span class="x">v-on:click="doThis"</span><span class="nt">&gt;&lt;button&gt;</span> 完整语法
一般使用这种简写方法
<span class="nt">&lt;div</span> id="example"<span class="nt">&gt;</span>
  <span class="nt">&lt;button</span> <span class="x">@:click</span>="<span class="x">say</span>('hi')"<span class="nt">&gt;</span>Say hi<span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;/div&gt;</span>
new Vue({
  el: '#example',
  <span class="x">methods</span>: {
    <span class="x">say</span>: function (message) {
      alert(message)
    }
  }
})
<span class="x">事件修饰符：</span>
<span class="nt">&lt;</span>!-- 阻止单击事件冒泡 --<span class="nt">&gt;</span>
<span class="nt">&lt;a</span> v-on:click.stop="doThis"<span class="nt">&gt;&lt;/a&gt;</span>
<span class="nt">&lt;</span>!-- 提交事件不再重载页面 --<span class="nt">&gt;</span>
<span class="nt">&lt;form</span> v-on:submit.prevent="onSubmit"<span class="nt">&gt;&lt;/form&gt;</span>
<span class="nt">&lt;</span>!-- 修饰符可以串联  --<span class="nt">&gt;</span>
<span class="nt">&lt;a</span> v-on:click.stop.prevent="doThat"<span class="nt">&gt;&lt;/a&gt;</span>
<span class="nt">&lt;</span>!-- 只有修饰符 --<span class="nt">&gt;</span>
<span class="nt">&lt;form</span> v-on:submit.prevent<span class="nt">&gt;&lt;/form&gt;</span>
<span class="nt">&lt;</span>!-- 添加事件侦听器时使用事件捕获模式 --<span class="nt">&gt;</span>
<span class="nt">&lt;div</span> v-on:click.capture="doThis"<span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;</span>!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --<span class="nt">&gt;</span>
<span class="nt">&lt;div</span> v-on:click.self="doThat"><span class="nt">&gt;&lt;/div&gt;</span>   

<span class="x">按键修饰符：</span>
记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：
<span class="nt">&lt;input</span> <span class="x">@keyup.enter</span>="submit"<span class="nt">&gt;</span>  
enter  tab   esc   space
delete (捕获 “删除” 和 “退格” 键)
up    down   left  right 
        </code></pre>
</div>
<div class="wrapper">
<p>属性绑定:</p>
    <pre class="highlight"><code>
（herf、src、id、name、class...）v-bind   可简写 ：
<span class="nt">&lt;img </span> <span class="x">v-bind:src</span>="imageSrc"<span class="nt">&gt; </span>
<span class="nt">&lt;div</span> <span class="x">:class</span>="{red:isRed}"<span class="nt">&gt;&lt;div&gt; </span>
<span class="nt">&lt;div</span> <span class="x">:class</span>="[classA,classB]"<span class="nt">&gt;&lt;div&gt; </span>
<span class="nt">&lt;div</span> <span class="x">:class</span>="[classA,{classB:isB,classC:isC}]"<span class="nt">&gt;&lt;div&gt; </span>
绑定内联样式
<span class="nt">&lt;div</span> v-bind<span class="x">:style="styleObject"</span> <span class="nt">&gt;&lt;div&gt; </span>
data: {
  <span class="gr">styleObject</span>: {
    color: 'red',
    fontSize: '13px'
  }
}
<span class="nt">&lt;div</span> v-bind:style="[baseStyles, overridingStyles]"<span class="nt">&gt;&lt;div&gt; </span> <span class="x">数组语法</span>  
当 v-bind:style 使用需要特定前缀的 CSS 属性时，
如 transform ，Vue.js 会<span class="x">自动侦测并添加</span>相应的前缀。         
    </code></pre>
</div>
<div class="wrapper">
<p>5. Vue.js 都提供了完全的 JavaScript 表达式支持。</p>
    <pre class="highlight">
        <code>
 {{ number + 1 }}
 {{ ok ? 'YES' : 'NO' }}
 {{ message.split('').reverse().join('') }}
 有个限制就是，每个绑定都只能包含单个表达式
 <span class="nt">&lt;div</span> v-bind:id="'list-' + id"<span class="nt">&gt;</span><span class="nt">&lt;div&gt; </span>    
        </code></pre>
</div>
<div class="wrapper">
<p>v-model指令 数据双向绑定</p>
    <pre class="highlight">
        <code>
<span class="nt">&lt;div</span> id="app"<span class="nt">div&gt;</span>
  <span class="nt">&lt;p&gt;</span><span class="x">{{ message }}</span><span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;input</span> <span class="x">v-model</span>="message"<span class="nt">&gt;</span>
<span class="nt">&lt;/div&gt;</span>
var app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
})             
        </code></pre>
</div>
<div class="wrapper">
<p>7.过滤器</p>
    <pre class="highlight">
        <code>
{{ message | <span class="x">capitalize</span> }}  过滤器函数总接受表达式的值作为第一个参数。   
new Vue({
  // ...
  filters: {
    capitalize: function (<span class="x">value</span>) {
      if (!value) return ''
      value = value.toString()
      return value.charAt(0).toUpperCase() + value.slice(1)
    }
  }
})
过滤器可以串联：
{{ message | filterA | filterB }}
过滤器是 JavaScript 函数，因此可以接受参数：
{{ message | filterA('arg1', arg2) }}
这里，字符串 'arg1' 将传给过滤器作为<span class="x">第二个</span>参数， arg2 表达式的值将被求值然后传给过滤器作为<span class="第三个"></span>参数            
        </code></pre>
</div>
<div class="language-html highlighter-rouge wrapper" >
<p>修饰符</p>
    <pre class="highlight">
        <code>
修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，
用于指出一个指定应该以特殊方式绑定。例如，.prevent
修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：
<span class="nt">&lt;form</span>  v-on:submit.prevent="onSubmit"<span class="nt">&gt;</span> <span class="nt">&lt;/form&gt;</span>
        </code></pre>
</div>
<div class="wrapper">
<p>组件</p>
    <pre class="highlight"><code>
全局组件:
在父组件引入import <span class="x">star</span> from 'components/star/star.vue';   
在父组件注册: 
<span class="x">components</span>: {
   star
}   

局部组件注册：
var <span class="x">Child</span> = {
  template: '<span class="nt">&lt;div&gt;</span>A custom component!<span class="nt">&lt;/div&gt;</span>'
}
new Vue({
  // ...
  components: {
    // <span class="nt">&lt</span>my-component<span class="nt">&gt;</span> 将只在父模板可用
    'my-component': <span class="x">Child</span>
  }
}) 

在组件中<span class="x">data</span>必须是一个<span class="x">函数</span>
由于多个组件共享了同一个 data ，因此增加一个 data
改变会影响所有组件！我们可以通过为每个组件返回新
的 data 对象来解决这个问题：

使用<span class="x">Props</span>传递数据
prop 是父组件用来传递数据的一个自定义属性。
子组件需要显式地用 props 选项 声明 “prop”：
<span class="nt">&lt;child</span> v-bind<span class="x">:message</span>="hello!"<span class="nt">&gt;</span><span class="nt">&lt;/child&gt;</span><span class="x">父组件在组件中传递数据</span>
 <span class="x">props</span>: ['message'], <span class="x">子组件接受</span>
<span class="x">组件可以为 props 指定验证要求。如果未指定验证要求，Vue 会发出警告</span>
  props: {
    // 基础类型检测 （`null` 意思是任何类型都可以）
    propA: Number,
    // 多种类型
    propB: [String, Number],
    // 必传且是字符串
    propC: {
      type: String,
      required: true
    },
    // 数字，有默认值
    propD: {
      type: Number,
      default: 100
    },
    // 数组／对象的默认值应当由一个工厂函数返回
    propE: {
      type: Object,
      default: function () {
        return { message: 'hello' }
      }
    },
    // 自定义验证函数
    propF: {
      validator: function (value) {
        return value > 10
      }
    }
  }

    </code></pre>
</div>
<div class="wrapper">
<p>子组件向父组件传递数据</p>
    <pre class="highlight"><code>
子组件发送
this.<span class="x">$emit</span>('<span class="x">child-info</span>', type);
父组件接收：
<span class="nt">&lt;ratingselect</span>  <span class="x">@child-info</span>="<span class="x">get</span>"<span class="nt">&gt;</span><span class="nt">&lt;/ratingselect&gt;</span>
methods: {
    <span class="x">get</span> (msg) {
        console.log(msg);
    }
}
    </code></pre>
</div>

<div class="wrapper">
<p>动态组件</p>
    <pre class="highlight"><code>
把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染
<span class="nt">&lt;keep-alive&gt;</span>
  <span class="nt">&lt;component</span> :is="currentView"<span class="nt">&gt;</span>
    <span class="nt">&lt;</span>!-- 非活动组件将被缓存！ --<span class="nt">&gt;</span>
  <span class="nt">&lt;/component&gt;</span>
<span class="nt">&lt;/keep-alive&gt;</span>
    </code></pre>
</div>

<div class="wrapper">
<p>过度效果</p>
    <pre class="highlight"><code>
<span class="nt">&lt;transition</span>  name="<span class="x">fade</span>"<span class="nt">&gt;</span> 
    <span class="nt">&lt;p</span>  v-if="show">hello<span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;/transition&gt;</span>  
.<span class="x">fade</span>-enter-active, .<span class="x">fade</span>-leave-active {
  <span class="x">transition</span>: opacity .5s
}
.<span class="x">fade</span>-enter, .<span class="x">fade</span>-leave-active {
  <span class="x">opacity</span>: 0
}    
类名过渡：
v-enter: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。
v-enter-active: 定义进入过渡的结束状态。在元素被插入时生效，在 transition/animation 完成之后移除。
v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。
v-leave-active: 定义离开过渡的结束状态。在离开过渡被触发时生效，在 transition/animation 完成之后移除。

/* 可以设置不同的进入和离开动画 */
/* 设置持续时间和动画函数 */
.slide-fade-enter-active {
  transition: all .3s ease;
}
.slide-fade-leave-active {
  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);
}
.slide-fade-enter, .slide-fade-leave-active {
  padding-left: 10px;
  opacity: 0;
}

css动画:
.bounce-enter-active {
  animation: bounce-in .5s;
}
.bounce-leave-active {
  animation: bounce-out .5s;
}
@keyframes bounce-in {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.5);
  }
  100% {
    transform: scale(1);
  }
}

<a href="http://doc.vue-js.com/v2/guide/transitions.html#同时使用-Transitions-和-Animations">同时使用 Transitions 和 Animations...点击进入</a>
    </code></pre>
</div>

<div class="wrapper">
<p>请求</p>
    <pre class="highlight"><code>
npm install <span class="x">vue-resource</span>  
引入resource插件: 
import VueResource from 'vue-resource'; 
<span class="x">Vue.use</span>(VueResource)  
this.$http.get('url', [options]).then((res) => { 
// 处理成功的结果}, (res) => { // 处理失败的结果});  

this.<span class="x">$http.post</span>("http://www.vrserver.applinzi.com/...", <span class="x">{name:"abc"}</span>,{emulateJSON:true}).then( 
   function (res) { 
    // 处理成功的结果 
    alert(res.body); 
   },function (res) { 
   // 处理失败的结果 
   } 
  ); 

new Vue({ ready() { 
 this. <span class="x">$http.jsonp</span>('/url', {name:"abc"}) .then(function (res){ 
  console.log(res) 
 }, function (res) { 
  console.log(res) 
  }); 
 } 
})
<a href="http://www.jb51.net/article/106565.htm">点击查看参数详细介绍</a>
    </code></pre>
</div>
<div class="wrapper">
    <pre class="highlight">
        <code>
new Vue({//new一个vue实例
  el: "#app",
  <span class="x">data</span>: {

  },
  <span class="x">filters</span>: { //过滤器
    formatMoney: function(value){
      return "￥"+value.toFixed(2);
    }
  },
  <span class="x">mounted</span>: function(){
    <span class="x">this.$nextTick</span>(function(){//页面加载完成后执行
        this.cartView();
    })
  },
  <span class="x">methods</span>: {
    cartView:function(){
     /**
      * <span class="x">箭头函数</span>=>相当于一个function
      * <span class="x">作用域指向外层</span>可以直接使用外面的this
      */
     this.$http.get("data/cartData.json",{<span class="x">可以添加参数</span>}).then(res=>{
        this.productList=res.data.result.list;
     })
    }
  },
  <span class="x">created()</span> {
  },
  <span class="x">computed</span>:{ //计算属性

  }
  <span class="x">components</span>: {//注册组件
      cartcontrol
  }
});
        </code>
    </pre>
</div>

<div class="wrapper">
    <p>路由</p>
    <pre class="highlight"><code>
1.安装
 (1)直接下载 / CDN  直接引入js <a href="https://github.com/vuejs/vue-router/tree/dev/dist">下载连接</a>
 (2)组件模块化工程开发中<span class="x">必须</span>要通过 Vue.use() 明确地安装路由功能
     npm install vue-router
     import Vue from 'vue'
     import VueRouter from 'vue-router'
     <span class="x">Vue.use</span>(VueRouter)
    </code></pre>
</div>

<div class="wrapper">
    <h3>vue中常见的问题</h3>
    <pre class="highlight"><code>
<span class="x">eslint</span>静态检查
vue-cli创建工程的时候，会有一项，使用使用eslint，如果选择了y，那么工程就会安装并启用eslint
多余的分号、定义了却未使用的变量、结尾多余空格、超过一行的空行、代码尾行应该有空行

<span class="x">sass使用</span>
首先安装依赖 npm i node-sass sass-loader -D
然后在vue的style里添加
<span class="nt">&lt;style</span>  <span class="k">lang="scss" scoped</span><span class="nt"> &gt;</span>

vue建议我们为片段添加一个根节点，这样方便传递props和过渡效果，也可以让dom
更好的溯源，所以，解决方法很简单，在 <span class="x">template的内部套一层div</span>即可

<span class="x">v-cloak</span>
如果出现{{}}的短暂出现的情况，可以通过添加v-cloak来处理。
这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。

<span class="x">转场动画</span>
在vue中有个很好用的指令，transition，通过它我们可以实现自定义的router切换中的动画
方法就是在
<span class="nt">&lt;router-view</span> transition="fade"<span class="nt">&gt;&lt;router-view&gt;</span>
加入自定义的class fade-transition , fade-leave , fade-enter即可。
      </code></pre>
</div>


<!--vue-router-->

<h1>vue-router</h1>
<div class="wrapper">
    <h3>vue-router如何参数传递</h3>
    <pre class="highlight"><code>
 <span class="x">一、用name传递参数</span>
1在路由文件src/router/index.js里<span class="x">配置name</span>属性。
 routes: [
    {
      path: '/',
      name: 'Hello',
      component: Hello
    }
 ]
2模板里(src/App.vue)用 <span class="x">$router.name的形式接收</span>，比如直接在模板中显示：
<span class="nt">&lt;p&gt;</span>{{ <span class="x">$route.name</span>}}<span class="nt">&lt;/p&gt;</span> //name为hello

<span class="x">二、通过<span class="nt">&lt;router-link&gt;</span> 标签中的to传参</span>
<span class="nt">&lt;router-link&gt;</span> <span class="x">:to</span>="<span class="k">{name:xxx,params:{key:value}}</span>" <span class="nt">&gt;</span>valueString<span class="nt">&lt;/router-link&gt;</span>
在xxx模板中{{ <span class="x">$route.params</span>.username}}进行接收
注意：此处to前面带有冒号 此处用path：‘xxx’无效   只能用name形式路由
    </code></pre>
</div>
<div class="wrapper">
    <h3>vue-router 利用url传递参数</h3>
    <pre class="highlight"><code>

    </code></pre>
</div>
<footer class="site-footer">
    <div class="wrapper">
        <div class="footer-col-wrapper">
            <div class="footer-col">
                <ul class="social-media-list">
                    <li>
                        <a href="https://github.com/zhanglibing"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
 </span><span class="username">zhanglibing</span></a>

                        <span>fullstack web developer
 </span>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
</body>
</html>