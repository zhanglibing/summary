<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>VUE</title>
    <link rel="stylesheet" href="css/index.css">
    <link rel="stylesheet" href="css/main.css">
</head>
<body>
<header class="site-header">
    <div class="wrapper">
        <a class="site-title" href="https://github.com/zhanglibing">zhanglibing</a>
    </div>
</header>

<div class="wrapper">
     <h2><a href="http://cn.vuejs.org/v2/guide/">1.VUE API</a></h2>
     <h2><a href="vueRouter.html">2.VUE-Router</a></h2>
     <h2><a href="vuex.html">3.VUEX</a></h2>
</div>

<!--vue-->
<div class="wrapper">
    <h1>VUEJS</h1>
    <ul>
        <li>
          <p>手机端测试方法</p>
          <pre class="highlight">
            <code>
 ipconfig（window系统）
 ifconfig（苹果系统）
 找到IPv4 地址 . . . : 192.168.31.180
 将localhost替换为192.168.31.180
 手机直接搜索网址进行测试  或者  进入网址cli.im   打开草料二维码   将网址生成二维码进行扫码测试
            </code></pre>
        </li>
        <li>
            <p>创建vue项目</p>
            <pre class="highlight">
                <code>
 <span class="x">npm install -g vue-cli</span>(如果电脑已安装过直接跳过)
 <span class="x">vue init webpack myapp</span>(项目名称)都选择no,项目生成好后cd到当前项目
 <span class="x">npm install</span>，安装所有依赖到node_modules目录中 （npm版本过低用npm install npm -g升级）
 <span class="x">npm run dev</span>运行项目
                </code></pre>
        </li>
    </ul>
</div>
<div class="wrapper">
    <p>1.数据渲染</p>
    <pre class="highlight">
        <code>
 v-text、v-html、 {{}}
 <span class="nt">&lt;p&gt;{{a}}&lt;/p&gt;</span>
 <span class="nt">&lt;p <span class="x">v-text="a"</span>&gt; </span>&lt;/p&gt;
 <span class="nt">&lt;p <span class="x">v-html="a"</span>&gt; </span>&lt;/p&gt;            
        </code></pre>
</div>
<div class="wrapper">
<p>2.控制模块隐藏：v-if、 v-show</p>
    <pre class="highlight">
        <code>
 &lt;p <span class="x">v-if="isShow"</span>&gt; &lt;/p&gt;
 &lt;p <span class="x">v-show="isShow"</span>&gt;&lt;/p&gt;  
一般来说， v-if 有更高的切换消耗而 v-show 有更高的
初始渲染消耗。因此，如果需要<span class="x">频繁切换使用 v-show</span> 较好，
如果在运行时条件<span class="x">不大可能改变</span>则使用 v-if 较好。          
        </code></pre>
</div>
<div class="wrapper">
    <p>3.渲染循环列表</p>
    <pre class="highlight"><code>
<span class="nt">&lt;ul&gt;</span>
  <span class="nt">&lt;li</span> <span class="x">v-for='item in items'</span> <span class="nt">&gt;</span>
     <span class="nt">&lt;p </span> <span class="x">v-text='item.lable'</span><span class="nt">&gt;</span><span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;/li&gt;</span>
<span class="nt">&lt;/ul&gt;</span>   
<span class="nt">&lt;li</span> v-for="(item, <span class="x">index</span>) in items"<span class="nt">&gt;</span>index当前项的索引
   {{ parentMessage }}-{{ index }}-{{ item.message }}

对象迭代 v-for
你也可以用 v-for 通过一个对象的属性来迭代。
<span class="nt">&lt;ul</span>  id="repeat-object" class="demo"<span class="nt">&gt;</span> 
  <span class="nt">&lt;/li</span> v-for="value in <span class="x">object</span>"<span class="nt">&gt;</span>
    {{ value }}
  <span class="nt">&lt;/li&gt;</span>
<span class="nt">&lt;/ul&gt;</span> 
new Vue({
  el: '#repeat-object',
  data: {
    <span class="x">object</span>: {
      FirstName: 'John',
      LastName: 'Doe',
      Age: 30
    }
  }
})   
<span class="nt">&lt;/li&gt;</span>  
你也可以提供第二个的参数为键名：
<span class="nt">&lt;/div</span>  v-for="(<span class="x">value, key</span>) in object"<span class="nt">&gt;</span> 
  {{ key }} : {{ value }}
<span class="nt">&lt;/div&gt;</span> 
第三个参数为索引：
<span class="nt">&lt;/div</span>  v-for="(<span class="x">value, key, index</span>) in object"<span class="nt">&gt;</span> 
  {{ index }}. {{ key }} : {{ value }}
<span class="nt">&lt;/div&gt;</span> 

整数迭代 v-for
v-for 也可以取整数。在这种情况下，它将重复多次模板。
<span class="nt">&lt;div&gt;</span> 
  <span class="nt">&lt;span&gt;</span>  v-for="n in 10"<span class="nt">&gt;</span> {{ n }}<span class="nt">&lt;/span&gt;</span> 
<span class="nt">&lt;/div&gt;</span>   结果：1 2 3 4 5 6 7 8 9 10 
        </code></pre>
</div>
<div class="wrapper">
<p>4.事件绑定</p>
    <pre class="highlight">
        <code>
<span class="nt">&lt;button</span> <span class="x">v-on:click="doThis"</span><span class="nt">&gt;&lt;button&gt;</span> 完整语法
一般使用这种简写方法
<span class="nt">&lt;div</span> id="example"<span class="nt">&gt;</span>
  <span class="nt">&lt;button</span> <span class="x">@:click</span>="<span class="x">say</span>('hi')"<span class="nt">&gt;</span>Say hi<span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;/div&gt;</span>
new Vue({
  el: '#example',
  <span class="x">methods</span>: {
    <span class="x">say</span>: function (message) {
      alert(message)
    }
  }
})
<span class="x">事件修饰符：</span>
<span class="nt">&lt;</span>!-- 阻止单击事件冒泡 --<span class="nt">&gt;</span>
<span class="nt">&lt;a</span> v-on:click.stop="doThis"<span class="nt">&gt;&lt;/a&gt;</span>
<span class="nt">&lt;</span>!-- 提交事件不再重载页面 --<span class="nt">&gt;</span>
<span class="nt">&lt;form</span> v-on:submit.prevent="onSubmit"<span class="nt">&gt;&lt;/form&gt;</span>
<span class="nt">&lt;</span>!-- 修饰符可以串联  --<span class="nt">&gt;</span>
<span class="nt">&lt;a</span> v-on:click.stop.prevent="doThat"<span class="nt">&gt;&lt;/a&gt;</span>
<span class="nt">&lt;</span>!-- 只有修饰符 --<span class="nt">&gt;</span>
<span class="nt">&lt;form</span> v-on:submit.prevent<span class="nt">&gt;&lt;/form&gt;</span>
<span class="nt">&lt;</span>!-- 添加事件侦听器时使用事件捕获模式 --<span class="nt">&gt;</span>
<span class="nt">&lt;div</span> v-on:click.capture="doThis"<span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;</span>!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --<span class="nt">&gt;</span>
<span class="nt">&lt;div</span> v-on:click.self="doThat"><span class="nt">&gt;&lt;/div&gt;</span>   

<span class="x">按键修饰符：</span>
记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：
<span class="nt">&lt;input</span> <span class="x">@keyup.enter</span>="submit"<span class="nt">&gt;</span>  
enter  tab   esc   space
delete (捕获 “删除” 和 “退格” 键)
up    down   left  right 
        </code></pre>
</div>
<div class="wrapper">
<p>属性绑定:</p>
    <pre class="highlight"><code>
（herf、src、id、name、class...）v-bind   可简写 ：
<span class="nt">&lt;img </span> <span class="x">v-bind:src</span>="imageSrc"<span class="nt">&gt; </span>
<span class="nt">&lt;div</span> <span class="x">:class</span>="{red:isRed}"<span class="nt">&gt;&lt;div&gt; </span>
<span class="nt">&lt;div</span> <span class="x">:class</span>="[classA,classB]"<span class="nt">&gt;&lt;div&gt; </span>
<span class="nt">&lt;div</span> <span class="x">:class</span>="[classA,{classB:isB,classC:isC}]"<span class="nt">&gt;&lt;div&gt; </span>
绑定内联样式
<span class="nt">&lt;div</span> v-bind<span class="x">:style="styleObject"</span> <span class="nt">&gt;&lt;div&gt; </span>
data: {
  <span class="gr">styleObject</span>: {
    color: 'red',
    fontSize: '13px'
  }
}
<span class="nt">&lt;div</span> v-bind:style="[baseStyles, overridingStyles]"<span class="nt">&gt;&lt;div&gt; </span> <span class="x">数组语法</span>  
当 v-bind:style 使用需要特定前缀的 CSS 属性时，
如 transform ，Vue.js 会<span class="x">自动侦测并添加</span>相应的前缀。         
    </code></pre>
</div>
<div class="wrapper">
<p>5. Vue.js 都提供了完全的 JavaScript 表达式支持。</p>
    <pre class="highlight">
        <code>
 {{ number + 1 }}
 {{ ok ? 'YES' : 'NO' }}
 {{ message.split('').reverse().join('') }}
 有个限制就是，每个绑定都只能包含单个表达式
 <span class="nt">&lt;div</span> v-bind:id="'list-' + id"<span class="nt">&gt;</span><span class="nt">&lt;div&gt; </span>    
        </code></pre>
</div>
<div class="wrapper">
<p>v-model指令 数据双向绑定</p>
    <pre class="highlight">
        <code>
<span class="nt">&lt;div</span> id="app"<span class="nt">div&gt;</span>
  <span class="nt">&lt;p&gt;</span><span class="x">{{ message }}</span><span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;input</span> <span class="x">v-model</span>="message"<span class="nt">&gt;</span>
<span class="nt">&lt;/div&gt;</span>
var app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
})             
        </code></pre>
</div>
<div class="wrapper">
<p>7.过滤器</p>
    <pre class="highlight">
        <code>
{{ message | <span class="x">capitalize</span> }}  过滤器函数总接受表达式的值作为第一个参数。   
new Vue({
  // ...
  filters: {
    capitalize: function (<span class="x">value</span>) {
      if (!value) return ''
      value = value.toString()
      return value.charAt(0).toUpperCase() + value.slice(1)
    }
  }
})
过滤器可以串联：
{{ message | filterA | filterB }}
过滤器是 JavaScript 函数，因此可以接受参数：
{{ message | filterA('arg1', arg2) }}
这里，字符串 'arg1' 将传给过滤器作为<span class="x">第二个</span>参数， arg2 表达式的值将被求值然后传给过滤器作为<span class="第三个"></span>参数            
        </code></pre>
</div>
<div class="language-html highlighter-rouge wrapper" >
<p>修饰符</p>
    <pre class="highlight">
        <code>
修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，
用于指出一个指定应该以特殊方式绑定。例如，.prevent
修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：
<span class="nt">&lt;form</span>  v-on:submit.prevent="onSubmit"<span class="nt">&gt;</span> <span class="nt">&lt;/form&gt;</span>
        </code></pre>
</div>

<!--父组件向子组件传值-->
<div class="wrapper">
<p>组件</p>
    <pre class="highlight"><code>
全局组件:
在父组件引入import <span class="x">star</span> from 'components/star/star.vue';   
在父组件注册: 
<span class="x">components</span>: {
   star
}   

局部组件注册：
var <span class="x">Child</span> = {
  template: '<span class="nt">&lt;div&gt;</span>A custom component!<span class="nt">&lt;/div&gt;</span>'
}
new Vue({
  // ...
  components: {
    // <span class="nt">&lt</span>my-component<span class="nt">&gt;</span> 将只在父模板可用
    'my-component': <span class="x">Child</span>
  }
}) 

在组件中<span class="x">data</span>必须是一个<span class="x">函数</span>
由于多个组件共享了同一个 data ，因此增加一个 data
改变会影响所有组件！我们可以通过为每个组件返回新
的 data 对象来解决这个问题：

使用<span class="x">Props</span>传递数据
prop 是父组件用来传递数据的一个自定义属性。
子组件需要显式地用 props 选项 声明 “prop”：
<span class="nt">&lt;child</span> v-bind<span class="x">:message</span>="hello!"<span class="nt">&gt;</span><span class="nt">&lt;/child&gt;</span><span class="x">父组件在组件中传递数据</span>
 <span class="x">props</span>: ['message'], <span class="x">子组件接受</span>
<span class="x">组件可以为 props 指定验证要求。如果未指定验证要求，Vue 会发出警告</span>
  props: {
    // 基础类型检测 （`null` 意思是任何类型都可以）
    propA: Number,
    // 多种类型
    propB: [String, Number],
    // 必传且是字符串
    propC: {
      type: String,
      required: true
    },
    // 数字，有默认值
    propD: {
      type: Number,
      default: 100
    },
    // 数组／对象的默认值应当由一个工厂函数返回
    propE: {
      type: Object,
      default: function () {
        return { message: 'hello' }
      }
    },
    // 自定义验证函数
    propF: {
      validator: function (value) {
        return value > 10
      }
    }
  }

<span class="x">**父组件向子组件传异步数据时
 子组件有时候获取不到值得情况</span>
 可以通过 <span class="x">watch监控</span>props里接受值  当监控到有值时进行处理数据、渲染（初始化组件数据）、
    </code></pre>
</div>

<!--组件之间数据传递-->
<div class="wrapper">
<h3>子组件向父组件传递数据$emrt()</h3>
    <pre class="highlight"><code>
子组件发送
<span class="nt">&lt;button @click="event"</span><span class="nt">&gt;</span>点击向父组件传递数据<span class="nt">&lt;/button</span><span class="nt">&gt;</span>
methods: {
    <span class="x">event</span> () {
        this.<span class="x">$emit</span>('<span class="x">child-info</span>', data);
    }
}

父组件接收：
<span class="nt">&lt;ratingselect</span>  <span class="x">@child-info</span>="<span class="x">get</span>"<span class="nt">&gt;</span><span class="nt">&lt;/ratingselect&gt;</span>
methods: {
    <span class="x">get</span> (data) {
        console.log(data);
    }
}

<span class="x">**如果能通过点击事件传值</span>尽量通过点击事件或者失焦等其他事件(watch监控传值频繁)
如果子组件中没有点击事件可以通过 <span class="x">watch监控数据 </span>
data:{
   return{
      aa:'',
      array:[],
      object:{}
   }
  },
  watch: {
    aa(newValue, oldValue) {
        console.log(newValue)
        <span class="x">传值</span>this.<span class="x">$emit</span>('<span class="x">child-info</span>', data);
    },
    object: {
　　　　handler(newValue, oldValue) {
　　　　　　console.log(newValue)
         <span class="x">传值</span>this.<span class="x">$emit</span>('<span class="x">child-info</span>', data);
　　　　},
　　　　deep: true
　　},
    array(newValue, oldValue) {
        <span class="x">传值</span>this.<span class="x">$emit</span>('<span class="x">child-info</span>', data);
　　　　　　for (let i = 0; i < newValue.length; i++) {
　　　　　　　　if (oldValue[i] != newValue[i]) {
　　　　　　　　　　console.log(newValue)
　　　　　　　　}
　　　　　　}
    deep: true
　　},
　　　　
  }
}
<span class="x">watch监控数组和对象</span>
 注意区别普通watch 数组和对象
    </code></pre>
</div>
<div class="wrapper">
    <h3>父组件调用子组件方法ref、$refs</h3>
    <pre class="highlight"><code>
父组件中引用的子组件
<span class="nt">&lt;child-model</span> <span class="x">ref="child"</span> <span class="nt">&gt;</span><span class="nt">&lt;child-model&gt;</span>
在父组件中调用子组件方法
this.<span class="x">$refs.child.</span>childMethods();
<span class="x">childMethods()</span>为子组件中的方法
    </code></pre>
</div>

<div class="wrapper">
<p>动态组件</p>
    <pre class="highlight"><code>
把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染
<span class="nt">&lt;keep-alive&gt;</span>
  <span class="nt">&lt;component</span> :is="currentView"<span class="nt">&gt;</span>
    <span class="nt">&lt;</span>!-- 非活动组件将被缓存！ --<span class="nt">&gt;</span>
  <span class="nt">&lt;/component&gt;</span>
<span class="nt">&lt;/keep-alive&gt;</span>
    </code></pre>
</div>

<div class="wrapper">
<p>过度效果</p>
    <pre class="highlight"><code>
<span class="nt">&lt;transition</span>  name="<span class="x">fade</span>"<span class="nt">&gt;</span> 
    <span class="nt">&lt;p</span>  v-if="show">hello<span class="nt">&lt;/p&gt;</span> 
<span class="nt">&lt;/transition&gt;</span>  
.<span class="x">fade</span>-enter-active, .<span class="x">fade</span>-leave-active {
  <span class="x">transition</span>: opacity .5s
}
.<span class="x">fade</span>-enter, .<span class="x">fade</span>-leave-active {
  <span class="x">opacity</span>: 0
}    
类名过渡：
v-enter: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。
v-enter-active: 定义进入过渡的结束状态。在元素被插入时生效，在 transition/animation 完成之后移除。
v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。
v-leave-active: 定义离开过渡的结束状态。在离开过渡被触发时生效，在 transition/animation 完成之后移除。

/* 可以设置不同的进入和离开动画 */
/* 设置持续时间和动画函数 */
.slide-fade-enter-active {
  transition: all .3s ease;
}
.slide-fade-leave-active {
  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);
}
.slide-fade-enter, .slide-fade-leave-active {
  padding-left: 10px;
  opacity: 0;
}

css动画:
.bounce-enter-active {
  animation: bounce-in .5s;
}
.bounce-leave-active {
  animation: bounce-out .5s;
}
@keyframes bounce-in {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.5);
  }
  100% {
    transform: scale(1);
  }
}

<a href="http://doc.vue-js.com/v2/guide/transitions.html#同时使用-Transitions-和-Animations">同时使用 Transitions 和 Animations...点击进入</a>
    </code></pre>
</div>

<div class="wrapper">
<p>请求</p>
    <pre class="highlight"><code>
npm install <span class="x">vue-resource</span>  
引入resource插件: 
import VueResource from 'vue-resource'; 
<span class="x">Vue.use</span>(VueResource)  
this.$http.get('url', [options]).then((res) => { 
// 处理成功的结果}, (res) => { // 处理失败的结果});  

this.<span class="x">$http.post</span>("http://www.vrserver.applinzi.com/...", <span class="x">{name:"abc"}</span>,{emulateJSON:true}).then( 
   function (res) { 
    // 处理成功的结果 
    alert(res.body); 
   },function (res) { 
   // 处理失败的结果 
   } 
  ); 

new Vue({ ready() { 
 this. <span class="x">$http.jsonp</span>('/url', {name:"abc"}) .then(function (res){ 
  console.log(res) 
 }, function (res) { 
  console.log(res) 
  }); 
 } 
})
<a href="http://www.jb51.net/article/106565.htm">点击查看参数详细介绍</a>
    </code></pre>
</div>
<div class="wrapper">
    <pre class="highlight">
        <code>
new Vue({//new一个vue实例
  el: "#app",
  <span class="x">data</span>: {

  },
  <span class="x">filters</span>: { //过滤器
    formatMoney: function(value){
      return "￥"+value.toFixed(2);
    }
  },
  <span class="x">mounted</span>: function(){
    <span class="x">this.$nextTick</span>(function(){//页面加载完成后执行
        this.cartView();
    })
  },
  <span class="x">methods</span>: {
    cartView:function(){
     /**
      * <span class="x">箭头函数</span>=>相当于一个function
      * <span class="x">作用域指向外层</span>可以直接使用外面的this
      */
     this.$http.get("data/cartData.json",{<span class="x">可以添加参数</span>}).then(res=>{
        this.productList=res.data.result.list;
     })
    }
  },
  <span class="x">created()</span> {
  },
  <span class="x">computed</span>:{ //计算属性

  }
  <span class="x">components</span>: {//注册组件
      cartcontrol
  }
});
        </code>
    </pre>
</div>

<div class="wrapper">
    <p>路由</p>
    <pre class="highlight"><code>
1.安装
 (1)直接下载 / CDN  直接引入js <a href="https://github.com/vuejs/vue-router/tree/dev/dist">下载连接</a>
 (2)组件模块化工程开发中<span class="x">必须</span>要通过 Vue.use() 明确地安装路由功能
     npm install vue-router
     import Vue from 'vue'
     import VueRouter from 'vue-router'
     <span class="x">Vue.use</span>(VueRouter)
    </code></pre>
</div>

<div class="wrapper">
    <h3>vue中常见的问题</h3>
    <pre class="highlight"><code>
<span class="x">eslint</span>静态检查
vue-cli创建工程的时候，会有一项，使用使用eslint，如果选择了y，那么工程就会安装并启用eslint
多余的分号、定义了却未使用的变量、结尾多余空格、超过一行的空行、代码尾行应该有空行

<span class="x">sass使用</span>
首先安装依赖 npm i node-sass sass-loader -D
然后在vue的style里添加
<span class="nt">&lt;style</span>  <span class="k">lang="scss" scoped</span><span class="nt"> &gt;</span>

vue建议我们为片段添加一个根节点，这样方便传递props和过渡效果，也可以让dom
更好的溯源，所以，解决方法很简单，在 <span class="x">template的内部套一层div</span>即可

<span class="x">v-cloak</span>
如果出现{{}}的短暂出现的情况，可以通过添加v-cloak来处理。
这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。

<span class="x">转场动画</span>
在vue中有个很好用的指令，transition，通过它我们可以实现自定义的router切换中的动画
方法就是在
<span class="nt">&lt;router-view</span> transition="fade"<span class="nt">&gt;&lt;router-view&gt;</span>
加入自定义的class fade-transition , fade-leave , fade-enter即可。
      </code></pre>
</div>

<!--引入全局jquery-->
<div class="wrapper">
    <h2>vue引入全局jquery</h2>
    <pre class="highlight"><code>
1 首先在 <span class="x">package.json</span>里加入，
    dependencies:{
     <span class="x">"jquery" : "^2.2.3"</span>
    }
    然后 nmp install 或者cnpm install

2 在 <span class="x">webpack.base.conf.js</span>里加入
  var webpack = require(" <span class="x">webpack</span>")

3 在<span class="x">module.exports</span>的最后加入
    plugins: [
     new webpack.optimize.CommonsChunkPlugin('common.js'),
     new webpack.ProvidePlugin({
         jQuery: "<span class="x">jquery</span>",
         $: "<span class="x">jquery</span>"
     })
    ]

4. 然后一定要重新 <span class="x">run dev</span>
5. 在main.js 引入就ok了
   import $ from '<span class="x">jquery</span>'
    </code></pre>
</div>

<div class="wrapper">
    <h2>引入公共组件 component</h2>
    <pre class="highlight"><code>
1.在 <span class="x">main.js</span>里import singleSelect from './components/functional_select/single_select' //引入
2.<span class="x">Vue.component</span>('singleSelect', singleSelect) //注册
3.<span class="x">所有路由页面</span>都可以使用singleSelect了
    </code></pre>
</div>

<div class="wrapper">
    <h2>路由中引入静态js</h2>
    <pre class="highlight"><code>
1.引入全局的静态js库，建立一个与src<span class="x">同级的目录</span>例如static
2.直接在根目录的index.html中引入，其他路由页面就都可以用了
<span class="nt">&lt;</span>script src="<span class="x">./static/js/</span>lib/jQuery.min.js"<span class="nt">&gt;</span><span class="nt">&lt;/script&gt;</span>
    </code></pre>
</div>

<div class="wrapper">
    <h2>axios请求</h2>
    <pre class="highlight"><code>
cnpm install --save <span class="x">qs axios</span>  安装依赖
<span class="b">入口js引入</span>
import <span class="x">qs</span> from 'qs'
import <span class="x">axios</span> from 'axios'
<span class="b">设置基本配置</span>
axios.defaults.<span class="x">baseURL</span> = 'http://www.clearbos.cn/';   全局设置默认host
axios.defaults.timeout = 5000;
axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';//POST传参序列化
axios.interceptors.request.use((config) => {
  if(config.method  === 'post'){
    config.data = qs.stringify(config.data);
  }
  return config;
},(error) =>{
  alert("错误的传参");
  return Promise.reject(error);
});
Vue.prototype.<span class="x">$http</span> = axios;  挂载到 Vue上
    </code></pre>
</div>

<div class="wrapper">
    <h2>注意问题</h2>
    <pre class="highlight"><code>
 1 在<span class="x">filters</span>过滤器中不能直接调用this.data 中的数据
    </code></pre>
</div>

<div class="wrapper">
    <h2>Vue调试神器vue-devtools安装</h2>
    <pre class="highlight"><code>
<span class="x">第一步：</span>找到vue-devtools的github项目，并将其clone到本地. vue-devtools
    git <span class="x">clone</span> https://github.com/vuejs/vue-devtools.git
<span class="x">第二步：</span>cd vue-devtools目录 安装项目所需要的npm包
    npm install //如果太慢的话，可以安装一个cnpm, 然后命令换成 cnpm install
<span class="x">第三步：</span>编译项目文件
    npm run <span class="x">build</span>
<span class="x">第四步：</span>添加至chrome游览器
游览器输入地址“<span class="x">chrome://extensions/</span>”进入扩展程序页面，点击“加载已解压的扩展程序...”按钮，选择vue-devtools>shells下的chrome文件夹。

/**
*如果看不见“加载已解压的扩展程序...”按钮，则需要勾选“开发者模式”。
*/
    </code></pre>
</div>

<div class="wrapper">
    <h2 style="text-align: left;">1.  <a href="http://element.eleme.io/#/zh-CN/component/input-number">PC端element ui</a><span style="font-size: 14px;">(图片上传、日期插件...)</span></h2>
    <h2 style="text-align: left;">2.  <a href="http://mint-ui.github.io/docs/#/zh-cn2">手机端mint ui</a><span style="font-size: 14px;">框架</span></h2>
    <pre class="highlight"><code>
# Vue 2.0
npm install mint-ui -S
 // 引入全部组件
import Vue from 'vue';
import Mint from 'mint-ui';
Vue.use(Mint);
    </code></pre>
</div>

<div class="wrapper">
    <h2>屏蔽滑动的遮罩层</h2>
    <pre class="highlight"><code>
  1.移动端 在遮罩层添加touchmove.prevent
   <span class="nt">&lt;div</span> class="overlayer" <span class="x">@touchmove.prevent </span><span class="nt">&gt;div</span>
    <span class="nt">&lt;div&gt;</span>
  2.PC端方案
   <span class="nt">&lt;div</span> class="overlayer" <span class="x">@@scroll.prevent </span><span class="nt">&gt;div</span>
   <span class="nt">&lt;div&gt;</span>
    </code></pre>
</div>

<div class="wrapper">
    <h2>Vue.directive自定义指令</h2>
    <pre class="highlight"><code>
<span class="b">组件中使用</span><span class="nt">&lt;div</span> <span class="x">v-title</span> <span class="nt">&gt;</span>诊前详情 <span class="nt">&lt;/div&gt;</span>

//全局title
<span class="b">Vue</span>.<span class="x">directive</span>('<span class="x">title</span>', {
  inserted:(el, binding)=> {
    document.title = el.innerText
    $(el).css({display:'none'});
  },
  update:(el, binding)=>{//组件更新后重新赋值
    document.title = el.innerText
  },
})
<span class="b">自定义指令中传递的三个参数</span>
<span class="x">el</span>: 指令所绑定的元素，可以用来直接操作DOM。
<span class="x">binding</span>:  一个对象，包含指令的很多信息。
<span class="x">vnode</span>: Vue编译生成的虚拟节点。

<span class="b">自定义指令的生命周期</span>
<span class="x">bind</span>:function(){//被绑定时调用  只调用一次
},
<span class="x">inserted</span>:function(){//绑定到节点
},
<span class="x">update</span>:function(){//组件更新
},
<span class="x">componentUpdated</span>:function(){//组件更新完成
},
<span class="x">unbind</span>:function(){//解绑时调用
}
    </code></pre>
</div>

<div class="wrapper">
    <h2>vue表单控件</h2>
    <pre class="highlight"><code>
<span class="b">修饰符</span>
<span class="nt">&lt;input</span> v-model<span class="x">.lazy</span>="msg" <span class="nt">&gt;</span>
在默认情况下，v-model 在 input 事件中同步输入框的值与数据，使用lazy转变为在 change 事件中同步：

<span class="nt">&lt;input</span> v-model<span class="x">.number</span>="age" type="number" <span class="nt">&gt;</span>
自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值）
因为在 type="number" 时 HTML 中输入的值也总是会返回字符串类型

<span class="nt">&lt;input</span> v-model<span class="x">.trim</span>="msg" <span class="nt">&gt;</span>
自动过滤用户输入的首尾空格

<span class="b">两种改变 prop 的情况</span>
1.prop 作为初始值传入，子组件之后只是将它的初始值作为本地数据的初始值使用；
2.prop 作为需要被转变的原始值传入。
props: ['initialCounter'],
data: function () {
  return { counter: this.initialCounter }
}
props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 <span class="kd">prop</span> 是一个 <span class="x">对象或数组</span>，
在子组件内部改变它会影响父组件的状态。

        <a href="http://cordova.axuer.com/docs/zh-cn/latest/reference/cordova-plugin-file/index.html">套壳APP</a>
        <a href="https://www.cnblogs.com/haoxuan/articles/5412103.html">套壳APP</a>
    </code></pre>

</div>
<div class="wrapper">
    <h2>项目中遇到的问题</h2>
    <pre class="highlight"><code>
 <span class="b">1.图片缓存问题</span>
  视图不及时跟新服务器图片  解决办法 在图片链接后添加随机数  <span class="x">:src="path...?${Math.random()}</span>"

  <span class="b">2.css均匀分布 text-align: justify</span>
  子元素如果是<span class="x">v-if</span>渲染   <span class="k">均匀分布失效</span>

  <span class="b">3.苹果手机input聚焦光标乱窜</span>
  遮罩或者父元素使用了<span class="k">position:fixed</span>  解决办法 使用绝对定位

  <span class="b">4.Vue.set 监控对象属性变化并及时实现view视图的更新。</span>
  <span class="b">5.子组件接受值动态监听对象、数组方法</span>
  <span class="b">6.beforeUpdate、updated</span>
  <span class="b">@change传参</span>
    @change="change($event,item.type)"
    </code></pre>
</div>

<footer class="site-footer">
    <div class="wrapper">
        <div class="footer-col-wrapper">
            <div class="footer-col">
                <ul class="social-media-list">
                    <li>
                        <a href="https://github.com/zhanglibing"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
 </span><span class="username">zhanglibing</span></a>

                        <span>fullstack web developer
 </span>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
</body>
</html>