<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>javascript</title>
    <link rel="stylesheet" href="css/index.css">
    <link rel="stylesheet" href="css/main.css">
</head>
<body>
<header class="site-header">

    <div class="wrapper">

        <a class="site-title" href="https://github.com/zhanglibing">zhanglibing</a>

    </div>

</header>
<div class="wrapper">
    <p>webstorm快捷键</p>
    <pre class="highlight"><code>
<span class="x">Shift+F6 </span> 重构-重命名  引用处也跟着修改
<span class="x">Ctrl+X</span> 删除行
<span class="x">Ctrl+G</span>  查找行
<span class="x">Ctrl+Shift+Up/Down</span> 代码向上/下移动。
<span class="x">F2 或Shift+F2</span>  高亮错误或警告快速定位
选中文本，<span class="x">Ctrl+Shift+F7</span> 高亮显示所有该文本，按Esc高亮消失。
<span class="x">Ctrl+B或Ctrl+鼠标左键单击</span> 快速打开光标处的类或方法，
<span class="x">Ctrl+Alt+L</span> 格式化代码
<span class="x">Shift+enter</span> 重新开始一行（无论光标在哪个位置）
<span class="x">shift+tab/tab</span> 减少/扩大缩进
<span class="x">ctrl+W	</span>选中单词
<span class="x">ctrl+]/[</span>	光标到代码块的前面或后面
    </code></pre>
</div>
<div class="wrapper">
    <h2>收藏插件库</h2>
    <pre class="highlight"><code>
   1.<a href="http://echarts.baidu.com/echarts2/doc/example.html">图形、k线...</a>
    </code></pre>
</div>
<div class="wrapper">
      <pre class="highlight"><code>
localStorage.getItem(‘key’,’val’) - 取得
localStorage.setItem(‘key’) - 设置
localStorage.removeItem(‘key’) - 移除
localStorage.key(0) - 取key值
localStorage.clear() - 清空
<span class="x">IE</span>的web存储 <span class="x">不支持本地测试</span>，。上传测试通过
      </code></pre>
</div>
<!--字符串、数组-->
<div class="wrapper">
    <h1>JavaScript基础</h1> <ol>
    <!--字符串、数组-->
        <li>
            <p>字符串</p>
            <pre class="highlight">
                <code>
var str = "ABCDECDF";
str.<span class="x">search(/CD/i)</span>//或str.search("CD");结果：2
返回与正则表达式查找内容匹配的第一个字符串的位置

str.<span class="x">substr</span>(start[,length]) 返回一个从指定位置开始的指定长度的子字符串。
str.<span class="x">substring</span>(start,end) 返回位于String对象中指定位置的子字符串。
str.<span class="x">slice</span>(start[,end])  返回字符串的片段。
   var str = "ABCDEF";
   str.slice(2,4); //"CD"
str.<span class="x">charAt</span>(index) 返回指定索引位置处的字符。如果超出有效范围的索引值返回空字符串。
str.<span class="x">fromCharCode</span>(65,66,112) 从一些Unicode字符串中返回一个字符串
str.<span class="x">charCodeAt</span>(index) 返回一个整数，代表指定位置字符的Unicode编码。
    var str = "ABC";
    str.charCodeAt(0);结果：65

str.<span class="x">indexOf</span>(substr,[startIndex]) 第一次出现子字符串位置
str.<span class="x">lastIndexOf</span>(substr,[startIndex]) 最后一次出现子字符串位置
    substr要查找的字符串 startIndex开始查找的位置
    如果没有找到子字符串，则返回-1。
<span class="x">toLowerCase 小写</span>返回值为字符串
<span class="x">toUpperCase 大写</span>返回值为字符串
<span class="x">str.concat([string1[,string2...]])</span>连接字符串
<span class="k">转化为数组</span>
var str= "abcd"
var arr=str. <span class="x">split("")</span>//["a", "b", "c", "d"]
                </code>
            </pre>
        </li>
        <li>
            <p>数组</p>
            <pre class="highlight">
                <code>
  str = fruits.toString()
 (1)新增:<span class="k">影响原数组</span>
   arr.<span class="k">push</span>('aa')末尾添加新的元素
   arr.<span class="k">unshift</span>('aa')数组的开头添加新元素  IE8以下不支持(插入的值将被返回成 undefined )
 (2)新增:<span class="k">不影响原数组</span>
   var arr1=["a","b","c"];
   var arr2=arr.<span class="x">concat</span>("f")//["a","b","c","f"];
   console.log(arr1)// ["a","b","c"]
   第二种方法：javascript的展开操作符(...)
   var arr1=["a","b","c"];
   var arr2=[<span class="x">...arr1</span>,"f"];//arr2=["a","b","c","f"];
   var arr2=["f",...arr1];
  展开符会复制原来的数组，从原数组中取出所有元素，然后存入新的环境
 (3)移除:<span class="k">影响原数组</span>
    arr.<span class="x">pop()</span>删除最后一个
    arr.<span class="x">shift()</span>删除第一个
    var arr1=["a","b","c"];
    arr1.<span class="x">splice(0,2)</span>//["c"] 0:开始下标 2:长度
    这三种移除都返回被删除的元素
 (4)移除:<span class="k">不影响原数组</span>
    var arr1=["a","b","c","d","e"];
    var arr2=arr1.<span class="x">filter(a=>a!=="e")</span>;//["a","b","c","d"];
    或者var arr2=arr1.<span class="x">filter(a=>{
      return a!="e"
    })</span>;//["a","b","c","d"];
         <span class="kd">单行箭头函数，'return'关键字是默认自带的不需要手动书写
    多行箭头函数就需要一个明确的返回值
    </span>
    还有一种方法截取
    arr.<span class="x">slice(1,5)</span> 两个下标
    arr.<span class="x">slice(2)</span>
 (5)替换:<span class="k">影响原数组</span>
    var arr=["a","b","c","d"];
    arr.splice(2,1,30);//["a","b",30,"d"];
    arr.splice(2,1,30,31);//["a","b",30,31,"d"];
 (6)替换:<span class="k">不影响原数组</span>
    var arr1=["a","b","c","d"];
    var arr2=arr1.<span class="x">map(item=>{
       if(item==="c"){
         item="cat"
       }
      return item;</span>
     });
     //arr2=["a","b","cat","d"]

    arr.map()可以用于转换数据，而不污染数据源
    var arr3=arr1.map(n=>n+"HI");
    //  ["aHI","bHI","catHI","dHI"]
 (7)arr.<span class="x">reverse</span>();将数组中元素颠倒顺序
 arr.<span class="x">sort</span>();();数组按照字母顺序排序
 (8)转化为字符串
  var ss=["a","b","c","d"]
  var s = ss.<span class="x">toString()</span>;//a,b,c,d
  var s = ss.<span class="x">join("")</span>;//"abcd"  <span class="gr">join(",")可以加分隔符</span>
                </code>
            </pre>
        </li>
    </ol>
</div>

<!--数组-->
<div class="wrapper">
    <p>数组去重</p>
<pre class="highlight"><code>
var arr=[1,2,5,8,9,58,58,3,2,5,6,8,8,78,98,54,58,98];
<span class="x">方法一</span>：
function aa(arr){
 var newarr=[];
 var obj={};
 for(var i=0;i&lt;arr.length;i++){
   if(!obj[arr[i]]){
    newarr.push(arr[i]);
    obj[array[i]]=true;
   }
 }
 return newarr
}
console.log(aa(arr))

<span class="x">方法二：</span>
 function aa(array){
    var newarr=[];
    for(var i=0;i&lt;array.length;i++){
       if(newarr.<span class="x">indexOf</span>(array[i])==-1){
         newarr.push(array[i])
       }
    }
   return newarr
 }

console.log(aa(arr))
    </code></pre>
</div>
<div class="wrapper">
    <p>jquery操作数组方法</p>
    <pre class="highlight"><code>
1.遍历 <span class="x">$.each</span>(arr, callback(key, val));
2. 筛选$.grep(arr, callback, invert)
invert为false表示对callback的筛选取反。 默认为true。
var a = [1, 2, 3, 4];
<span class="x">$.grep</span>(a, function(val, key) {  //不能链式调用，返回[],所以可以加上return实现链式,返回满足条件的副本
　　if (a[key] > 2) {
　　　　console.log(key);
　　}
　　return val;
});
console.log(a)//[3,4]
3.转换 <span class="x">$.map</span>(arr,callback(key,val))
var a = [1, 2, 3, 4];
$.map(a, function(val, key) { //不能链式调用，返回[],同grep加上return即可放回副本
    if (a[key] > 2) {
        a[key]=val+1;
    }
    return val;              //可以链式调用，返回处理后的数组(也可用于筛选)
});
console.log(a) //[2, 3, 4, 5]
4 <span class="x">$.merge</span>(arr1,arr2)  合并数组 arr1后面加上arr2后 <span class="k">返回arr1</span>
5 <span class="x">$.unique</span>(arr)//过滤Jquery对象数组中重复的元素
6 <span class="x">$.inArray</span>(val,arr)  <span class="k">判断val是否在arr里面返回val对应的下标   如果没有找到则返回-1</span>
    </code></pre>
</div>

<!--对象-->
<div class="wrapper">
    <h3>对象</h3>
    <pre class="highlight"><code>
键值对：

创建对象的三种方法：
（1）字面量 var obj={x:1};
（2）var obj=new Foo();
（3）var obj=Object.create({x:1});
属性操作：
读写obj.x
   obj[x] 键为变量时用中括号方法取值
   for(p in obj){} 可能会把对象原型链上的属性也读取出来、并且顺序是不确定的
删除 <span class="x">delete</span>
1.var val=(1,2,3); //val =3;逗号运算符
2.var obj={x:1};
   <span class="x">delete</span> pbj.x;
   obj.x;//undefined
3.ie9 开始  var obj={};
  <span class="x">Object.defineProperty</span>(obj,'x',{
  <span class="x">configurable</span>:false,
  value:1
});
<span class="x">delete</span> obj.x;//false
obj.x;//1

 <span class="x">对象合并方法</span>
 1 <span class="x">遍历赋值</span>
 var extend=function(o,n){
     for (var p in n){
        if(<span class="x">n.hasOwnProperty</span>(p) && ( <span class="x">!o.hasOwnProperty</span>(p) ))
             o[p]=n[p];
     }
 };
2 var obj = Object.<span class="x">assign({},o1, o2, o3);</span>  //IE9以下不支持
3 <span class="x">jquery方法</span>
 o3 = $.<span class="x">extend</span>(o1, o2)  // 合并 o1 和 o2， 将结果返回给 o3. 注意： 此时，o1 == o3! 即 o1 被修改
 o3 = $.extend({}, o1, o2) // 合并 o1 和 o2， 将结果返回给 o3. 注意： 此时，o1 ！= o3! 即 o1 没有被修改

<span class="x" style="font-size: 18px">判断对象为空的方法</span>
Object.keys(obj).length=0 时为空对象

    </code></pre>
</div>

<!--数组排序以及数组对象排序-->
<div class="wrapper">
    <p>sort数组排序</p>
    <pre class="highlight"><code>
<span class="x">数字数组排序</span>
var arr=[1,2,8,2,9,52];
arr.sort(function(a,b){return <span class="x">a-b</span>}); <span class="k">此处用a-b或者b-a  若a-b>0或者a-b<0时排序有误</span>
arr.sort();

<span class="x">数组对象排序</span>
var by = function(name){
 return function(o, p){
   var a, b;
   if (typeof o === "object" && typeof p === "object" && o && p) {
     a = o[name];
     b = p[name];
     if (a === b) {
       return 0;
     }
     if (typeof a === typeof b) {
       return a < b ? -1 : 1;
     }
     return typeof a < typeof b ? -1 : 1;
   }
   else {
     throw ("error");
   }
 }
}
var employees=[{name:"George", age:32, retiredate:"March 12, 2014"}，
        {name:"Edward", age:17, retiredate:"June 2, 2023"}，
        {name:"Christine", age:58, retiredate:"December 20, 2036"}，
        {name:"Sarah", age:62, retiredate:"April 30, 2020"}
        ]
employees.sort(by("age"));

<span>两个参数进行比较</span>
当o[age] 和 p[age] 相等时，次要比较函数被用来决出高下
var by = function(name,minor){
 return function(o,p){
   var a,b;
   if(o && p && typeof o === 'object' && typeof p ==='object'){
     a = o[name];
     b = p[name];
     if(a === b){
       return typeof minor === 'function' ? minor(o,p):0;
     }
     if(typeof a === typeof b){
       return a < b ? -1:1;
     }
     return typeof a < typeof b ? -1 : 1;
   }else{
     thro("error");
   }
 }
}

employees.sort(by('age',by('name')));
    </code></pre>
</div>

<div class="wrapper">
    <h1>事件</h1>
    <ol>
        <li>
            <pre class="highlight">
                <code>
<span class="x">e.button</span>==0 鼠标左键  1:中键 2右键 3:鼠标左右键同时按下
                </code>
            </pre>

        </li>
        <li>
            <p>手机端滑动事件问题</p>
            <pre class="highlight">
                  <code>
H=e.originalEvent.changedTouches[0].pageY;
endPos = {x: l-n,y:h-H};
isScrolling = Math.abs(endPos.x) < Math.abs(endPos.y) ? 1:0;
  //isScrolling为1时，表示纵向滑动，0为横向滑动
if(isScrolling ===0) {
event.preventDefault(); //阻止横向触摸事件的默认行为
}
 ****** 如果不阻止默认事件苹果手机滑动会反应慢
如果不调用上下滑动可直接使用event.preventDefault();
                  </code>
              </pre>

        </li>
        <li>
            <p>ajax请求</p>
            <pre class="highlight">
                <code>
 var apiAjax = function() <span class="p">{</span>
   var self = this;
   this.host = 'http://www.clearbos.com';
   //this.host = 'http://localhost:39571'; //本地调试
   this.post = function (options, success, error) {
     $.ajax({
       type: "POST",
       url: self.host + options.path+"?opertionType="+options.opertionType,
       data:JSON.stringify(options.params),
       contentType: "application/json",
       success: function (msg) {
       msg = <span class="nb">eval("(" + msg + ")");</span> //将后台返回值转化为json对象格式
       success(msg, options);
       },
       error: function (msg) {
          msg = eval("(" + msg + ")");
          error(msg, options);
       }
     });
   }
 this.TeethStatus = function (params, success, error) {
   var options = {
   path: '/ClinicalOpRequirements.ashx',
   opertionType:'TeethChangeStatus',
   params: params
   }
   this.post(options, success, error);
 }
 <span class="p">}</span>
var api=new apiAjax();
                </code>
            </pre>

        </li>
    </ol>
</div>

<!--作用域链-->
<div class="wrapper">
    <h1>作用域</h1>
    <ol>
        <li>
            <p>作用域优先级</p>
            <pre class="highlight">
                <code>
 var test=10;
function testFn(){
     var test;
     console.log(test);
     test=100;
}
testFn();<span class="x">//undefined</span>
                </code>
            </pre>

        </li>
        <li>
            <p>变量声明被提升的机制</p>
            <pre class="highlight">
                <code>
 <span class="k">test()</span>; //test1
 var test=function(){
     console.log("test");
 }
 function test(){
    console.log("test1")
 }
 <span class="k">test()</span>; //test函数声明会被提升到作用域的最前面<br>
                </code>
            </pre>

        </li>
        <li>
            <pre class="highlight">
                <code>
  test(); // <span class="x">test is not a function</span>
  var test=function(){
       console.log("test");
  }
                </code>
            </pre>
        </li>
    </ol>

</div>

<!--面向对象-->
<div class="wrapper">
    <h1>面向对象</h1>
    <ol>
        <li>
            <p>混合模式（原型模式 + 构造函数模式）</p>
            <pre class="highlight">
                <code>
 function Blog(name, url, friend) {
    this.name = name;
    this.url = url;
    this.friend = friend;
 }
 Blog.<span class="k">prototype</span>.alertInfo = function() {
    alert(this.name + this.url + this.friend);
 }
 var blog = new Blog('wuyuchang', 'http://tools.jb51.net/', ['fr1', 'fr2', 'fr3'])
 var blog2 = new Blog('wyc', 'http://**.com', ['a', 'b']);
                </code>
            </pre>
        </li>
    </ol>
</div>

<!--this指向-->
<div class="wrapper">
    <h1>this指向</h1>
    <ol>
        <li>
            <p>this方法</p>
            <pre class="highlight">
               <code>
 谁调用指向谁 <br>
 var checkThis = function(){
      alert( this.x);
 };
 var x = 'this is a property of window';
 <span class="k">//var window.x</span> = 'this is a property of window';
 var obj = {};
 obj.x = 100;
 obj.y = function(){ alert( this.x ); };
 obj.y(); <span class="x">// 100</span>
 checkThis();  <span class="x">//'this is a property of window'</span>
 <span class="k">全局变量都是window对象的属性</span>
               </code>
            </pre>
        </li>
        <li>
            <p>call和apply可以重新定义this的指向</p>
            <pre class="highlight">
                <code>
function changeStyle( type , value ){
     this.style[ type ] = value;
}
 var one = document.getElementByIdx( 'one' );
 changeStyle.<span class="k">call</span>( <span class="gr">one</span> ,<span class="kr">'fontSize','100px'</span> );
 changeStyle.<span class="k">apply</span>( <span class="gr">one</span>, <span class="kr">['fontSize','100px']</span>);
 changeStyle('fontSize' , '300px'); //出现错误，因为此时changeStyle中this引用的是window对象，而window并无style属性。
     /**changeStyle.<span class="x">call()</span>中有三个参数，<span class="x">第一个参数用于指定该函数将被哪个对象所调用</span>。这里指定了one，也就意味着，
 changeStyle函数将被one调用，因此函数体内this指向是one对象。**/
     <span class="x">apply只接受两个参数，第一个参数和call相同，第二个参数必须是一个数组</span> ，数组中的元素对应的就是函数的形参。

 var x = 0;
 function test() {
   alert(this.x);
 }
 var o = {x : 1, m : test};
 o.m. <span class="k">apply()</span>; //0
 o.m. <span class="k">apply(o)</span>;//1
 <span class="x">当apply没有参数时，表示为全局对象。所以值为0。</span>
                </code>
            </pre>
        </li>
        <li>
            <p>new改变this指向</p>
            <pre class="highlight">
                <code>
function demo() {
    console.log(this);
}
demo();  // <span class="x"> window</span>
new demo();  // <span class="x"> demo</span>
                </code>
            </pre>
        </li>
    </ol>
</div>
<div class="wrapper">
    <h1>函数方法</h1>
    <ol>
        <li>
            <p>函数参数方法</p>
            <pre class="highlight">
                <code>
   function test(){
       <span class="k"> arguments</span> 参数数组
        arguments.length 参数的个数
   }
                </code>
            </pre>
        </li>
    </ol>
</div>

<!--闭包-->
<div class="wrapper">
    <h1>闭包</h1>
    <pre class="highlight">
        <code>
好处(1)读取函数内部的变量，
   (2)让这些变量的值始终保持在内存中。
var scope = "global scope";
function checkscope(){
    var <span class="k">scope</span>  = "local scope";
    function f(){
        return scope;
    }
    return f;
}
var foo = checkscope();//function f(){return scope;}
foo();
console.log(foo()) // <span class="x">"local scope"</span>

function f1(){
　　var n=999;
　　nAdd=function(){n+=1}
　　function f2(){
　　　　alert(n);
　　}
　　return f2;
}
var result=f1();
result();  <span class="x">// 999</span>
nAdd();
result(); <span class="x"> //1000</span>
    f1是f2的父函数，而f2被赋给了一个全局变量，
这导致f2始终在内存中，而f2的存在依赖于f1，因此
f1也始终在内存中，不会在调用结束后，被垃圾回收
机制（garbage collection）回收。
"nAdd=function(){n+=1}"这一行，首先在nAdd
前面没有使用var关键字，因此 <span class="x">nAdd是一个全局变量</span>，
而不是局部变量。其次，nAdd的值是一个匿名函数，
而这个匿名函数本身也是一个闭包，所以nAdd相当于
是一个setter，可以在函数外部对函数内部的局部变量进行操作。

理解闭包：
var name = "The Window";
var object = {
　　name : "My Object",
　　getNameFunc : function(){
     <span class="x">//var that=this;</span>
　　　　return function(){
　　　　　　return this.name;
　　　<span class="x">//return that.name; //"My Object"</span>
　　　　};
　　}
};
alert(object.getNameFunc()()); // <span class="x">"The Window"</span>

function outerFun(){
    //没有var
    a =0;
    alert(a);
}
var a=4;
outerFun();// <span class="x">0</span>
alert(a); // <span class="x">0</span>
 作用域链是描述一种路径的术语,沿着该路径可以确定变量的值
当执行a=0时,因为没有使用var关键字,因此赋值操作会沿着作用域
        </code>
    </pre>
</div>

<div class="wrapper">
    <h3>Location 对象属性</h3>
    <pre class="highlight"><code>
hash	    设置或返回从井号 (#) 开始的 URL（锚）。
host	    设置或返回主机名和当前 URL 的端口号。
hostname	设置或返回当前 URL的 <span class="x">主机名、域名</span>。
href	    设置或返回完整的 URL。
pathname	设置或返回当前 URL 的<span class="x">路径部分</span>。
port	    设置或返回当前 URL 的端口号。
protocol	设置或返回当前 URL 的 <span class="x">协议</span> (http\https)。
search	    设置或返回从问号 (?) 开始的 URL <span class="x">（查询部分）</span>。
assign()	加载新的文档。
reload()	重新加载当前文档。
replace()	用新的文档替换当前文档。
    </code></pre>
</div>
<div class="wrapper">
    <pre class="highlight"><code>
<span class="x">搜索功能</span>
<span class="x">window.location.href</span>='doct_index.html?keyword='value; value为搜索值
 var url = <span class="x">window.location.search</span>; //获取url中"?"符后的字串
var theRequest = new Object();
if (url.indexOf("?") != -1) {
    var str = url.substr(1);
    strs = str.split("&");
    for (var i = 0; i < strs.length; i++) {
        theRequest[strs[i].split("=")[0]] = <span class="x">decodeURI</span>(strs[i].split("=")[1]);
        //之前用了unescape() <span class="x">decodeURI</span>将url进行解码
    }
 }
    </code></pre>
</div>
<div class="wrapper">
    <h3>解析xml文件</h3>
    <pre class="highlight"><code>
javascript解析xml文件时xml文件只能有一个跟标签 否则加载xml文件会失败
$.ajax({
    url:'PatientID.xml', //相对html的路径
    type: 'GET',
    dataType: 'xml',
    timeout: 1000,  //设定超时  
    cache: false,   //禁用缓存 
    error: function(xml) {
        alert("加载XML文档出错!");
    },
    success:getXml
});
function getXml(xml){
    var xmlDom=xml;
    var elements = <span class="x">$(xmlDom).find("标签名")</span> ;
    $.each(elements,function(i,v){
        var name=<span class="x">$(this)[0].firstChild.nodeValue</span>; //获取值得方法
        createHtml(name,path);
    })
    setImageSize()
}

<span class="x">桌面html引入c盘某个文件下的图片</span>   C:/Users/Administrator/AppData/Roaming/ClearBos/201705050003/Data1/45Profile.jpg
    </code></pre>
</div>

<!--textarea编辑框换行-->
<div class="wrapper">
    <h2>textarea编辑框换行</h2>
    <pre class="highlight"><code>
  <span class="b">1.placeholder换行</span>
    <span class="x"><span>&</span>#10;</span> 进行换行
  <span class="b">2.边界框内容保存时保留换行空格</span>
  textEncode:function(str){  //<span class="k">转码保存到数据库</span>
        str = str.replace(/<span class="x">\n</span>/g, '<span class="x">_@</span>').replace(/<span class="x">\r</span>/g, '<span class="x">_#</span>');
        return str;
  },
  textDecode:function(str){ //<span class="k">反转义 用于普通元素赋值</span>
        str = str.replace(/<span class="x">_@</span>/g, '<span class="x">&lt;br/&gt;</span>');//IE9、FF、chrome
        str = str.replace(/<span class="x">\s</span>/g, '<span class="x">&nb</span><span class="x">sp;</span>');//空格处理
        return str;
  },
  textAreaDecode:function(str){ //<span class="k">反转义 用于textarea赋值</span>
        str = str.replace(/<span class="x">_@</span>/g, '<span class="x">\n</span>').replace(/<span class="x">_#</span>/g, '<span class="x">\r</span>');
        return str;
  },


    </code></pre>
</div>
<!--底部-->
<footer class="site-footer">

    <div class="wrapper">

        <div class="footer-col-wrapper">
            <div class="footer-col">
                <ul class="social-media-list">

                    <li>
                        <a href="https://github.com/zhanglibing"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">zhanglibing</span></a>

                        <span>fullstack web developer
</span>
                    </li>

                </ul>
            </div>
        </div>

    </div>

</footer>
</body>

</html>