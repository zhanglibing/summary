<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>javascript</title>
    <link rel="stylesheet" href="css/index.css">
    <link rel="stylesheet" href="css/main.css">
</head>
<body>
<header class="site-header">

    <div class="wrapper">

        <a class="site-title" href="https://github.com/zhanglibing">zhanglibing</a>

    </div>

</header>
<!--javascript-->
<div class="wrapper">
    <h1>JavaScript基础</h1> <ol>
    <!--字符串、数组-->
        <li>
            <p>字符串</p>
            <pre class="highlight">
                <code>
var str = "ABCDECDF";
str.<span class="x">search(/CD/i)</span>//或str.search("CD");结果：2
返回与正则表达式查找内容匹配的第一个字符串的位置

str.<span class="x">substr</span>(start[,length]) 返回一个从指定位置开始的指定长度的子字符串。
str.<span class="x">substring</span>(start,end) 返回位于String对象中指定位置的子字符串。
str.<span class="x">slice</span>(start[,end])  返回字符串的片段。
   var str = "ABCDEF";
   str.slice(2,4); //"CD"
str.<span class="x">charAt</span>(index) 返回指定索引位置处的字符。如果超出有效范围的索引值返回空字符串。
str.<span class="x">fromCharCode</span>(65,66,112) 从一些Unicode字符串中返回一个字符串
str.<span class="x">charCodeAt</span>(index) 返回一个整数，代表指定位置字符的Unicode编码。
    var str = "ABC";
    str.charCodeAt(0);结果：65

str.<span class="x">indexOf</span>(substr,[startIndex]) 第一次出现子字符串位置
str.<span class="x">lastIndexOf</span>(substr,[startIndex]) 最后一次出现子字符串位置
    substr要查找的字符串 startIndex开始查找的位置
    如果没有找到子字符串，则返回-1。
<span class="x">toLowerCase 小写</span>返回值为字符串
<span class="x">toUpperCase 大写</span>返回值为字符串
<span class="x">str.concat([string1[,string2...]])</span>连接字符串
<span class="k">转化为数组</span>
var str= "abcd"
var arr=str. <span class="x">split("")</span>//["a", "b", "c", "d"]
                </code>
            </pre>
        </li>
        <li>
            <p>数组</p>
            <pre class="highlight">
                <code>
  str = fruits.toString()
 (1)新增:<span class="k">影响原数组</span>
   arr.<span class="k">push</span>('aa')末尾添加新的元素
   arr.<span class="k">unshift</span>('aa')数组的开头添加新元素  IE8以下不支持(插入的值将被返回成 undefined )
 (2)新增:<span class="k">不影响原数组</span>
   var arr1=["a","b","c"];
   var arr2=arr.<span class="x">concat</span>("f")//["a","b","c","f"];
   console.log(arr1)// ["a","b","c"]
   第二种方法：javascript的展开操作符(...)
   var arr1=["a","b","c"];
   var arr2=[<span class="x">...arr1</span>,"f"];//arr2=["a","b","c","f"];
   var arr2=["f",...arr1];
  展开符会复制原来的数组，从原数组中取出所有元素，然后存入新的环境
 (3)移除:<span class="k">影响原数组</span>
    arr.<span class="x">pop()</span>删除最后一个
    arr.<span class="x">shift()</span>删除第一个
    var arr1=["a","b","c"];
    arr1.<span class="x">splice(0,2)</span>//["c"] 0:开始下标 2:长度
    这三种移除都返回被删除的元素
 (4)移除:<span class="k">不影响原数组</span>
    var arr1=["a","b","c","d","e"];
    var arr2=arr1.<span class="x">filter(a=>a!=="e")</span>;//["a","b","c","d"];
    或者var arr2=arr1.<span class="x">filter(a=>{
      return a!="e"
    })</span>;//["a","b","c","d"];
         <span class="kd">单行箭头函数，'return'关键字是默认自带的不需要手动书写
    多行箭头函数就需要一个明确的返回值
    </span>
    还有一种方法截取
    arr.<span class="x">slice(1,5)</span> 两个下标
    arr.<span class="x">slice(2)</span>
 (5)替换:<span class="k">影响原数组</span>
    var arr=["a","b","c","d"];
    arr.splice(2,1,30);//["a","b",30,"d"];
    arr.splice(2,1,30,31);//["a","b",30,31,"d"];
 (6)替换:<span class="k">不影响原数组</span>
    var arr1=["a","b","c","d"];
    var arr2=arr1.<span class="x">map(item=>{
       if(item==="c"){
         item="cat"
       }
      return item;</span>
     });
     //arr2=["a","b","cat","d"]

    arr.map()可以用于转换数据，而不污染数据源
    var arr3=arr1.map(n=>n+"HI");
    //  ["aHI","bHI","catHI","dHI"]
 (7)arr.<span class="x">reverse</span>();将数组中元素颠倒顺序
 arr.<span class="x">sort</span>();();数组按照字母顺序排序
 (8)转化为字符串
  var ss=["a","b","c","d"]
  var s = ss.<span class="x">toString()</span>;//a,b,c,d
  var s = ss.<span class="x">join("")</span>;//"abcd"  <span class="gr">join(",")可以加分隔符</span>
                </code>
            </pre>
        </li>
    </ol>
</div>

<div class="wrapper">
    <h1>事件</h1>
    <ol>
        <li>
            <pre class="highlight">
                <code>
<span class="x">e.button</span>==0 鼠标左键  1:中键 2右键 3:鼠标左右键同时按下
                </code>
            </pre>

        </li>
        <li>
            <p>手机端滑动事件问题</p>
            <pre class="highlight">
                  <code>
H=e.originalEvent.changedTouches[0].pageY;
endPos = {x: l-n,y:h-H};
isScrolling = Math.abs(endPos.x) < Math.abs(endPos.y) ? 1:0;
  //isScrolling为1时，表示纵向滑动，0为横向滑动
if(isScrolling ===0) {
event.preventDefault(); //阻止横向触摸事件的默认行为
}
 ****** 如果不阻止默认事件苹果手机滑动会反应慢
如果不调用上下滑动可直接使用event.preventDefault();
                  </code>
              </pre>

        </li>
        <li>
            <p>ajax请求</p>
            <pre class="highlight">
                <code>
 var apiAjax = function() <span class="p">{</span>
   var self = this;
   this.host = 'http://www.clearbos.com';
   //this.host = 'http://localhost:39571'; //本地调试
   this.post = function (options, success, error) {
     $.ajax({
       type: "POST",
       url: self.host + options.path+"?opertionType="+options.opertionType,
       data:JSON.stringify(options.params),
       contentType: "application/json",
       success: function (msg) {
       msg = <span class="nb">eval("(" + msg + ")");</span> //将后台返回值转化为json对象格式
       success(msg, options);
       },
       error: function (msg) {
          msg = eval("(" + msg + ")");
          error(msg, options);
       }
     });
   }
 this.TeethStatus = function (params, success, error) {
   var options = {
   path: '/ClinicalOpRequirements.ashx',
   opertionType:'TeethChangeStatus',
   params: params
   }
   this.post(options, success, error);
 }
 <span class="p">}</span>
var api=new apiAjax();
                </code>
            </pre>

        </li>
    </ol>
</div>

<!--作用域链-->
<div class="wrapper">
    <h1>作用域</h1>
    <ol>
        <li>
            <p>作用域优先级</p>
            <pre class="highlight">
                <code>
 var test=10;
function testFn(){
     var test;
     console.log(test);
     test=100;
}
testFn();<span class="x">//undefined</span>
                </code>
            </pre>

        </li>
        <li>
            <p>变量声明被提升的机制</p>
            <pre class="highlight">
                <code>
 <span class="k">test()</span>; //test1
 var test=function(){
     console.log("test");
 }
 function test(){
    console.log("test1")
 }
 <span class="k">test()</span>; //test函数声明会被提升到作用域的最前面<br>
                </code>
            </pre>

        </li>
        <li>
            <pre class="highlight">
                <code>
  test(); // <span class="x">test is not a function</span>
  var test=function(){
       console.log("test");
  }
                </code>
            </pre>
        </li>
    </ol>

</div>

<!--面向对象-->
<div class="wrapper">
    <h1>面向对象</h1>
    <ol>
        <li>
            <p>混合模式（原型模式 + 构造函数模式）</p>
            <pre class="highlight">
                <code>
 function Blog(name, url, friend) {
    this.name = name;
    this.url = url;
    this.friend = friend;
 }
 Blog.<span class="k">prototype</span>.alertInfo = function() {
    alert(this.name + this.url + this.friend);
 }
 var blog = new Blog('wuyuchang', 'http://tools.jb51.net/', ['fr1', 'fr2', 'fr3'])
 var blog2 = new Blog('wyc', 'http://**.com', ['a', 'b']);
                </code>
            </pre>
        </li>
    </ol>
</div>

<!--this指向-->
<div class="wrapper">
    <h1>this指向</h1>
    <ol>
        <li>
            <p>this方法</p>
            <pre class="highlight">
               <code>
 谁调用指向谁 <br>
 var checkThis = function(){
      alert( this.x);
 };
 var x = 'this is a property of window';
 <span class="k">//var window.x</span> = 'this is a property of window';
 var obj = {};
 obj.x = 100;
 obj.y = function(){ alert( this.x ); };
 obj.y(); <span class="x">// 100</span>
 checkThis();  <span class="x">//'this is a property of window'</span>
 <span class="k">全局变量都是window对象的属性</span>
               </code>
            </pre>
        </li>
        <li>
            <p>call和apply可以重新定义this的指向</p>
            <pre class="highlight">
                <code>
function changeStyle( type , value ){
     this.style[ type ] = value;
}
 var one = document.getElementByIdx( 'one' );
 changeStyle.<span class="k">call</span>( <span class="gr">one</span> ,<span class="kr">'fontSize','100px'</span> );
 changeStyle.<span class="k">apply</span>( <span class="gr">one</span>, <span class="kr">['fontSize','100px']</span>);
 changeStyle('fontSize' , '300px'); //出现错误，因为此时changeStyle中this引用的是window对象，而window并无style属性。
     /**changeStyle.<span class="x">call()</span>中有三个参数，<span class="x">第一个参数用于指定该函数将被哪个对象所调用</span>。这里指定了one，也就意味着，
 changeStyle函数将被one调用，因此函数体内this指向是one对象。**/
     <span class="x">apply只接受两个参数，第一个参数和call相同，第二个参数必须是一个数组</span> ，数组中的元素对应的就是函数的形参。

 var x = 0;
 function test() {
   alert(this.x);
 }
 var o = {x : 1, m : test};
 o.m. <span class="k">apply()</span>; //0
 o.m. <span class="k">apply(o)</span>;//1
 <span class="x">当apply没有参数时，表示为全局对象。所以值为0。</span>
                </code>
            </pre>
        </li>
        <li>
            <p>new改变this指向</p>
            <pre class="highlight">
                <code>
function demo() {
    console.log(this);
}
demo();  // <span class="x"> window</span>
new demo();  // <span class="x"> demo</span>
                </code>
            </pre>
        </li>
    </ol>
</div>
<div class="wrapper">
    <h1>函数方法</h1>
    <ol>
        <li>
            <p>函数参数方法</p>
            <pre class="highlight">
                <code>
   function test(){
       <span class="k"> arguments</span> 参数数组
        arguments.length 参数的个数
   }
                </code>
            </pre>
        </li>
    </ol>
</div>

<!--闭包-->
<div class="wrapper">
    <h1>闭包</h1>
    <pre class="highlight">
        <code>
好处(1)读取函数内部的变量，
   (2)让这些变量的值始终保持在内存中。
var scope = "global scope";
function checkscope(){
    var <span class="k">scope</span>  = "local scope";
    function f(){
        return scope;
    }
    return f;
}
var foo = checkscope();//function f(){return scope;}
foo();
console.log(foo()) // <span class="x">"local scope"</span>

function f1(){
　　var n=999;
　　nAdd=function(){n+=1}
　　function f2(){
　　　　alert(n);
　　}
　　return f2;
}
var result=f1();
result();  <span class="x">// 999</span>
nAdd();
result(); <span class="x"> //1000</span>
    f1是f2的父函数，而f2被赋给了一个全局变量，
这导致f2始终在内存中，而f2的存在依赖于f1，因此
f1也始终在内存中，不会在调用结束后，被垃圾回收
机制（garbage collection）回收。
"nAdd=function(){n+=1}"这一行，首先在nAdd
前面没有使用var关键字，因此 <span class="x">nAdd是一个全局变量</span>，
而不是局部变量。其次，nAdd的值是一个匿名函数，
而这个匿名函数本身也是一个闭包，所以nAdd相当于
是一个setter，可以在函数外部对函数内部的局部变量进行操作。

理解闭包：
var name = "The Window";
var object = {
　　name : "My Object",
　　getNameFunc : function(){
     <span class="x">//var that=this;</span>
　　　　return function(){
　　　　　　return this.name;
　　　<span class="x">//return that.name; //"My Object"</span>
　　　　};
　　}
};
alert(object.getNameFunc()()); // <span class="x">"The Window"</span>

function outerFun(){
    //没有var
    a =0;
    alert(a);
}
var a=4;
outerFun();// <span class="x">0</span>
alert(a); // <span class="x">0</span>
 作用域链是描述一种路径的术语,沿着该路径可以确定变量的值
当执行a=0时,因为没有使用var关键字,因此赋值操作会沿着作用域
        </code>
    </pre>
</div>


<!--底部-->
<footer class="site-footer">

    <div class="wrapper">

        <div class="footer-col-wrapper">
            <div class="footer-col">
                <ul class="social-media-list">

                    <li>
                        <a href="https://github.com/zhanglibing"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">zhanglibing</span></a>

                        <span>fullstack web developer
</span>
                    </li>

                </ul>
            </div>
        </div>

    </div>

</footer>
</body>
<script>
//    var Person = function(name, age) {
//        this.name = name;
//        this.age = age;
//        this.getName = function() {
//            return this.name;
//        }
//    }
//
//    // 将构造函数以参数形式传入
//    function New(func) {
//
//        // 声明一个中间对象，该对象为最终返回的实例
//        var res = {};
//        if (func.prototype !== null) {
//
//            // 将实例的原型指向构造函数的原型
//            res.__proto__ = func.prototype;
//            console.log(res.__proto__)
//        }
//
//        // ret为构造函数执行的结果，这里通过apply，将构造函数内部的this指向修改为指向res，即为实例对象
//        var ret = func.apply(res, Array.prototype.slice.call(arguments, 1));
//        console.log(Array.prototype.slice.call(arguments, 1)) //['tom', 20]
//
//        // 当我们在构造函数中明确指定了返回对象时，那么new的执行结果就是该返回对象
//        if ((typeof ret === "object" || typeof ret === "function") && ret !== null) {
//            return ret;
//        }
//
//        // 如果没有明确指定返回对象，则默认返回res，这个res就是实例对象
//        return res;
//    }
//
//    // 通过new声明创建实例，这里的p1，实际接收的正是new中返回的res
//    var p1 = New(Person, 'tom', 20);
//    console.log(p1);
//
//    // 当然，这里也可以判断出实例的类型了
//    console.log(p1 instanceof Person); // true
var data = [];

for (var i = 0; i<3; i++) {
    data[i] = function () {
        console.log(i);
    };
}


data[0]();
data[1]();
data[2]();

var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}

var foo = checkscope();
foo();
console.log(checkscope()) //"local scope"

</script>
</html>